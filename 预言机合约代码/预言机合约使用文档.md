# Pyth Oracle é“¾ä¸Šåˆçº¦è°ƒç”¨ API æ–‡æ¡£

## æ¦‚è¿°

æœ¬æ–‡æ¡£ä¸“é—¨ä»‹ç»å¦‚ä½•åœ¨ Solidity æ™ºèƒ½åˆçº¦ä¸­è°ƒç”¨ Pyth Oracle çš„**æ•´åˆ†ä»·æ ¼æ•°æ®**ã€‚æ•´åˆ†ä»·æ ¼æœºåˆ¶æ˜¯æœ¬Oracleç³»ç»Ÿçš„æ ¸å¿ƒç‰¹æ€§ï¼Œä¸ºæ™ºèƒ½åˆçº¦æä¾›ç²¾ç¡®çš„æ—¶é—´åŸºå‡†å’Œä¸€è‡´æ€§ä¿è¯ã€‚

## ğŸ• æ•´åˆ†ä»·æ ¼æœºåˆ¶ - é“¾ä¸Šè°ƒç”¨çš„æ ¸å¿ƒ

### ä»€ä¹ˆæ˜¯æ•´åˆ†ä»·æ ¼ï¼Ÿ

æ•´åˆ†ä»·æ ¼æ˜¯æŒ‡åœ¨æ¯ä¸ªæ•´åˆ†é’Ÿæ—¶åˆ»ï¼ˆå¦‚ 07:10:00ã€07:11:00ï¼‰æ¨é€çš„ä»·æ ¼æ•°æ®ï¼Œå…¶ `publishTime` æ—¶é—´æˆ³çš„ç§’æ•°å’Œæ¯«ç§’æ•°å‡ä¸º0ï¼Œç¡®ä¿ï¼š

- **æ—¶é—´ç²¾ç¡®æ€§**: æ‰€æœ‰ä»·æ ¼éƒ½åœ¨æ•´åˆ†é’Ÿæ—¶åˆ»å‘å¸ƒ
- **ä¸€è‡´æ€§ä¿è¯**: åŒä¸€åˆ†é’Ÿå†…æ‰€æœ‰åˆçº¦è°ƒç”¨è·å¾—ç›¸åŒä»·æ ¼
- **å¯é¢„æµ‹æ€§**: å¼€å‘è€…å¯ä»¥å‡†ç¡®é¢„æœŸä»·æ ¼æ›´æ–°æ—¶é—´
- **å…¬å¹³æ€§**: ä¸ºé¢„æµ‹å¸‚åœºå’ŒæœŸæƒåˆçº¦æä¾›å…¬å¹³çš„ç»“ç®—åŸºå‡†

### ğŸš€ æ•´åˆ†ä»·æ ¼åœ¨é“¾ä¸Šçš„æ ¸å¿ƒä¼˜åŠ¿

**é“¾ä¸Šæ•´åˆ†ä»·æ ¼è°ƒç”¨çš„æ ¸å¿ƒä»·å€¼**ï¼š

- **é¢„æµ‹å¸‚åœºç»“ç®—**: æä¾›ç²¾ç¡®çš„æ—¶é—´åŸºå‡†ç”¨äºé¢„æµ‹ç»“æœç¡®å®š
- **æœŸæƒåˆçº¦åˆ°æœŸ**: åœ¨ç‰¹å®šåˆ†é’Ÿæ—¶åˆ»è·å–å‡†ç¡®çš„ç»“ç®—ä»·æ ¼
- **DeFiåè®®è§¦å‘**: åŸºäºæ•´åˆ†é’Ÿä»·æ ¼çš„è‡ªåŠ¨åŒ–åè®®æ‰§è¡Œ
- **ä»·æ ¼ç«çŒœæ¸¸æˆ**: å…¬å¹³é€æ˜çš„ä»·æ ¼å‚è€ƒç‚¹
- **æ—¶é—´ä¸€è‡´æ€§**: ç¡®ä¿æ‰€æœ‰åˆçº¦è°ƒç”¨è·å¾—ç›¸åŒæ—¶é—´ç‚¹çš„ä»·æ ¼

## åˆçº¦ä¿¡æ¯

- **Oracleåˆçº¦åœ°å€**: `0x132923f95FD7E8a6FD8aC302D8fd92317F23aFfd`
- **ç½‘ç»œ**: Socrates Testnet
- **RPC**: https://rpc-testnet.socrateschain.org
- **Chain ID**: 1111111
- **æ¥å£**: `IPyth.sol`

## æ¥å£å®šä¹‰

### IPyth æ¥å£

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

interface IPyth {
    struct Price {
        int64 price;          // ä»·æ ¼ï¼ˆå¸¦æŒ‡æ•°å°æ•°ä½ï¼‰
        uint64 conf;          // ç½®ä¿¡åŒºé—´
        int32 expo;           // æŒ‡æ•°ï¼ˆå°æ•°ä½æ•°ï¼Œé€šå¸¸ä¸º-8ï¼‰
        uint publishTime;     // å‘å¸ƒæ—¶é—´æˆ³ï¼ˆUnixæ—¶é—´ï¼Œæ•´åˆ†é’Ÿï¼‰
    }

    struct PriceFeed {
        bytes32 id;           // ä»·æ ¼feedæ ‡è¯†ç¬¦
        Price price;          // å½“å‰ä»·æ ¼
        Price emaPrice;       // æŒ‡æ•°ç§»åŠ¨å¹³å‡ä»·æ ¼
    }

    // ==================== åŸºç¡€ä»·æ ¼æŸ¥è¯¢å‡½æ•° ====================

    /// @notice è·å–æŒ‡å®šfeedçš„å½“å‰ä»·æ ¼ï¼ˆæ•´åˆ†ä»·æ ¼ï¼‰
    /// @param id ä»·æ ¼feedæ ‡è¯†ç¬¦
    /// @return price ä»·æ ¼ç»“æ„ä½“ï¼ŒpublishTimeä¸ºæ•´åˆ†é’Ÿæ—¶åˆ»
    function getPrice(bytes32 id) external view returns (Price memory price);

    /// @notice è·å–å®Œæ•´çš„ä»·æ ¼feedä¿¡æ¯
    /// @param id ä»·æ ¼feedæ ‡è¯†ç¬¦
    /// @return priceFeed åŒ…å«å½“å‰ä»·æ ¼å’ŒEMAä»·æ ¼çš„å®Œæ•´ä¿¡æ¯
    function getPriceFeed(bytes32 id) external view returns (PriceFeed memory priceFeed);

    /// @notice è·å–ä¸è¶…è¿‡æŒ‡å®šæ—¶æ•ˆçš„ä»·æ ¼
    /// @param id ä»·æ ¼feedæ ‡è¯†ç¬¦
    /// @param age æœ€å¤§å…è®¸çš„ä»·æ ¼å¹´é¾„ï¼ˆç§’ï¼‰
    /// @return price ä»·æ ¼ç»“æ„ä½“
    function getPriceNoOlderThan(bytes32 id, uint age) external view returns (Price memory price);

    /// @notice è·å–EMAä»·æ ¼
    /// @param id ä»·æ ¼feedæ ‡è¯†ç¬¦
    /// @return price EMAä»·æ ¼ç»“æ„ä½“
    function getEmaPrice(bytes32 id) external view returns (Price memory price);

    /// @notice æ£€æŸ¥ä»·æ ¼feedæ˜¯å¦å­˜åœ¨
    /// @param id ä»·æ ¼feedæ ‡è¯†ç¬¦
    /// @return exists æ˜¯å¦å­˜åœ¨
    function priceFeedExists(bytes32 id) external view returns (bool exists);

    /// @notice è·å–ä»·æ ¼ï¼ˆä¸æ£€æŸ¥æ—¶æ•ˆæ€§ï¼Œå¯èƒ½è¿‡æ—¶ï¼‰
    /// @param id ä»·æ ¼feedæ ‡è¯†ç¬¦
    /// @return price ä»·æ ¼ç»“æ„ä½“
    function getPriceUnsafe(bytes32 id) external view returns (Price memory price);

    // ==================== V2 æ–°å¢ï¼šå†å²æ•´åˆ†ä»·æ ¼æŸ¥è¯¢å‡½æ•° ====================

    /// @notice è·å–æŒ‡å®šæ•´åˆ†é’Ÿæ—¶é—´æˆ³çš„å†å²ä»·æ ¼ â­ æ ¸å¿ƒå‡½æ•°
    /// @dev è¿™æ˜¯è·å–å†å²æ•´åˆ†ä»·æ ¼çš„ä¸»è¦å‡½æ•°ï¼Œé€‚ç”¨äºé¢„æµ‹å¸‚åœºç»“ç®—ç­‰åœºæ™¯
    /// @param id ä»·æ ¼feedæ ‡è¯†ç¬¦
    /// @param timestamp æ•´åˆ†é’Ÿæ—¶é—´æˆ³ï¼ˆå¿…é¡»æ˜¯60çš„å€æ•°ï¼‰
    /// @return price æŒ‡å®šæ—¶é—´çš„ä»·æ ¼æ•°æ®
    function getPriceAtZeroTimestamp(
        bytes32 id, 
        uint256 timestamp
    ) external view returns (Price memory price);

    /// @notice è·å–æœ€è¿‘çš„æ•´åˆ†é’Ÿä»·æ ¼
    /// @param id ä»·æ ¼feedæ ‡è¯†ç¬¦
    /// @return price æœ€è¿‘è®°å½•çš„æ•´åˆ†é’Ÿä»·æ ¼
    function getLastZeroPrice(bytes32 id) external view returns (Price memory price);

    /// @notice è·å–æ‰€æœ‰æ•´åˆ†é’Ÿæ—¶é—´æˆ³åˆ—è¡¨
    /// @param id ä»·æ ¼feedæ ‡è¯†ç¬¦
    /// @return timestamps æ‰€æœ‰å·²è®°å½•çš„æ•´åˆ†é’Ÿæ—¶é—´æˆ³æ•°ç»„
    function getZeroTimestamps(bytes32 id) external view returns (uint256[] memory timestamps);

    /// @notice åˆ†é¡µè·å–æ•´åˆ†é’Ÿæ—¶é—´æˆ³
    /// @param id ä»·æ ¼feedæ ‡è¯†ç¬¦
    /// @param offset èµ·å§‹åç§»é‡
    /// @param limit è¿”å›æ•°é‡é™åˆ¶
    /// @return timestamps æ—¶é—´æˆ³æ•°ç»„
    function getZeroTimestampsPaginated(
        bytes32 id,
        uint256 offset,
        uint256 limit
    ) external view returns (uint256[] memory timestamps);

    /// @notice æ‰¹é‡è·å–å¤šä¸ªæ—¶é—´æˆ³çš„ä»·æ ¼
    /// @param id ä»·æ ¼feedæ ‡è¯†ç¬¦
    /// @param timestamps æ—¶é—´æˆ³æ•°ç»„
    /// @return prices å¯¹åº”çš„ä»·æ ¼æ•°ç»„
    function getBatchPricesAtZero(
        bytes32 id,
        uint256[] calldata timestamps
    ) external view returns (Price[] memory prices);

    /// @notice æ£€æŸ¥æ˜¯å¦å¯ä»¥åœ¨æŒ‡å®šæ—¶é—´æˆ³è®¾ç½®ä»·æ ¼
    /// @param id ä»·æ ¼feedæ ‡è¯†ç¬¦
    /// @param timestamp æ—¶é—´æˆ³
    /// @return canSet æ˜¯å¦å¯ä»¥è®¾ç½®
    /// @return reason ä¸èƒ½è®¾ç½®çš„åŸå› 
    function canSetPriceAtZero(
        bytes32 id,
        uint256 timestamp
    ) external view returns (bool canSet, string memory reason);
}
```

## ä»·æ ¼Feedå¸¸é‡

```solidity
// ä»·æ ¼Feed IDå¸¸é‡å®šä¹‰
library PythFeeds {
    /// @notice BTC/USD ä»·æ ¼feed ID
    /// @dev é€šè¿‡ keccak256("BTCUSD") ç”Ÿæˆ
    bytes32 public constant BTC_USD = 0x7404e3d104ea7841c3d9e6fd20adfe99b4ad586bc08d8f3bd3afef894cf184de;
    
    /// @notice ä»·æ ¼ç²¾åº¦å¸¸é‡ï¼ˆ8ä½å°æ•°ï¼‰
    int32 public constant PRICE_EXPO = -8;
    uint256 public constant PRICE_PRECISION = 1e8;
}
```

## åŸºç¡€åˆçº¦ç¤ºä¾‹

### 1. ç®€å•ä»·æ ¼æŸ¥è¯¢åˆçº¦

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./IPyth.sol";

contract SimplePriceConsumer {
    IPyth public immutable pyth;
    bytes32 public constant BTC_FEED_ID = 0x7404e3d104ea7841c3d9e6fd20adfe99b4ad586bc08d8f3bd3afef894cf184de;
    
    constructor(address _pyth) {
        pyth = IPyth(_pyth);
    }
    
    /// @notice è·å–BTCå½“å‰ä»·æ ¼ï¼ˆæ•´åˆ†ä»·æ ¼ï¼‰
    /// @return price ä»·æ ¼ï¼ˆUSDï¼Œ8ä½å°æ•°ï¼‰
    /// @return timestamp ä»·æ ¼æ—¶é—´æˆ³ï¼ˆæ•´åˆ†é’Ÿï¼‰
    function getBTCPrice() external view returns (uint256 price, uint256 timestamp) {
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        require(priceData.price > 0, "Invalid price");
        require(priceData.expo == -8, "Unexpected price exponent");
        
        // éªŒè¯æ•´åˆ†é’Ÿæ—¶é—´æˆ³
        require(priceData.publishTime % 60 == 0, "Price timestamp not minute-aligned");
        
        return (
            uint256(uint64(priceData.price)),
            priceData.publishTime
        );
    }
    
    /// @notice è·å–BTCä»·æ ¼ï¼ˆUSDæ ¼å¼ï¼Œå»é™¤å°æ•°ä½ï¼‰
    /// @return priceInUSD ä»·æ ¼ï¼ˆUSDï¼Œæ•´æ•°éƒ¨åˆ†ï¼‰
    function getBTCPriceInUSD() external view returns (uint256 priceInUSD) {
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        require(priceData.price > 0, "Invalid price");
        require(priceData.expo == -8, "Unexpected price exponent");
        
        // è½¬æ¢ä¸ºUSDï¼ˆé™¤ä»¥10^8ï¼‰
        return uint256(uint64(priceData.price)) / 1e8;
    }
    
    /// @notice æ£€æŸ¥ä»·æ ¼æ˜¯å¦ä¸ºæŒ‡å®šåˆ†é’Ÿçš„ä»·æ ¼
    /// @param targetMinute ç›®æ ‡åˆ†é’Ÿæ—¶é—´æˆ³ï¼ˆå¿…é¡»ä¸ºæ•´åˆ†é’Ÿï¼‰
    /// @return isMatch æ˜¯å¦åŒ¹é…
    function isPriceForMinute(uint256 targetMinute) external view returns (bool isMatch) {
        require(targetMinute % 60 == 0, "Target minute must be minute-aligned");
        
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        return priceData.publishTime == targetMinute;
    }
    
    /// @notice éªŒè¯å¹¶è·å–æ•´åˆ†ä»·æ ¼ï¼ˆå¸¦å®Œæ•´éªŒè¯ï¼‰
    /// @return price ä»·æ ¼ï¼ˆUSDï¼Œ8ä½å°æ•°ï¼‰
    /// @return timestamp æ•´åˆ†é’Ÿæ—¶é—´æˆ³
    /// @return isValid ä»·æ ¼æ˜¯å¦æœ‰æ•ˆ
    function getValidatedMinutePrice() external view returns (
        uint256 price, 
        uint256 timestamp, 
        bool isValid
    ) {
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        // éªŒè¯ä»·æ ¼åŸºæœ¬æœ‰æ•ˆæ€§
        if (priceData.price <= 0 || priceData.expo != -8) {
            return (0, 0, false);
        }
        
        // æ ¸å¿ƒéªŒè¯ï¼šç¡®ä¿æ˜¯æ•´åˆ†é’Ÿä»·æ ¼
        if (priceData.publishTime % 60 != 0) {
            return (0, 0, false);
        }
        
        // éªŒè¯ä»·æ ¼ä¸è¶…è¿‡5åˆ†é’Ÿ
        if (block.timestamp - priceData.publishTime > 300) {
            return (0, 0, false);
        }
        
        return (
            uint256(uint64(priceData.price)),
            priceData.publishTime,
            true
        );
    }
    
    /// @notice è·å–å½“å‰åˆ†é’Ÿçš„ä»·æ ¼ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    /// @return price å½“å‰åˆ†é’Ÿä»·æ ¼
    /// @return available æ˜¯å¦å¯ç”¨
    function getCurrentMinutePrice() external view returns (uint256 price, bool available) {
        // è®¡ç®—å½“å‰æ•´åˆ†é’Ÿæ—¶é—´æˆ³
        uint256 currentMinute = (block.timestamp / 60) * 60;
        
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        if (priceData.publishTime == currentMinute && priceData.price > 0) {
            return (uint256(uint64(priceData.price)), true);
        }
        
        return (0, false);
    }
    
    /// @notice ç­‰å¾…å¹¶è·å–ä¸‹ä¸€ä¸ªæ•´åˆ†é’Ÿä»·æ ¼ï¼ˆè§†å›¾å‡½æ•°ï¼Œç”¨äºé¢„æµ‹ï¼‰
    /// @return nextMinuteTimestamp ä¸‹ä¸€ä¸ªæ•´åˆ†é’Ÿæ—¶é—´æˆ³
    /// @return secondsToWait éœ€è¦ç­‰å¾…çš„ç§’æ•°
    function getNextMinuteInfo() external view returns (uint256 nextMinuteTimestamp, uint256 secondsToWait) {
        uint256 currentMinute = (block.timestamp / 60) * 60;
        nextMinuteTimestamp = currentMinute + 60;
        secondsToWait = nextMinuteTimestamp - block.timestamp;
    }
    
    // ==================== V2 æ–°å¢ï¼šå†å²ä»·æ ¼æŸ¥è¯¢ç¤ºä¾‹ ====================
    
    /// @notice è·å–æŒ‡å®šæ—¶é—´çš„å†å²ä»·æ ¼ â­ æ ¸å¿ƒåŠŸèƒ½
    /// @param targetTimestamp ç›®æ ‡æ•´åˆ†é’Ÿæ—¶é—´æˆ³
    /// @return price å†å²ä»·æ ¼
    /// @return isValid æ˜¯å¦æ‰¾åˆ°æœ‰æ•ˆä»·æ ¼
    function getHistoricalPrice(uint256 targetTimestamp) external view returns (
        uint256 price, 
        bool isValid
    ) {
        require(targetTimestamp % 60 == 0, "Timestamp must be minute-aligned");
        
        try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, targetTimestamp) returns (IPyth.Price memory priceData) {
            require(priceData.price > 0, "Invalid historical price");
            return (uint256(uint64(priceData.price)), true);
        } catch {
            return (0, false);
        }
    }
    
    /// @notice è·å–æœ€è¿‘Nåˆ†é’Ÿçš„ä»·æ ¼å†å²
    /// @param minutesBack å›æº¯åˆ†é’Ÿæ•°
    /// @return prices ä»·æ ¼æ•°ç»„
    /// @return timestamps å¯¹åº”çš„æ—¶é—´æˆ³æ•°ç»„
    function getRecentPriceHistory(uint256 minutesBack) external view returns (
        uint256[] memory prices,
        uint256[] memory timestamps
    ) {
        require(minutesBack > 0 && minutesBack <= 60, "Invalid minutes range");
        
        uint256 currentMinute = (block.timestamp / 60) * 60;
        prices = new uint256[](minutesBack);
        timestamps = new uint256[](minutesBack);
        
        for (uint256 i = 0; i < minutesBack; i++) {
            uint256 targetTime = currentMinute - (i * 60);
            timestamps[minutesBack - 1 - i] = targetTime;
            
            try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, targetTime) returns (IPyth.Price memory priceData) {
                if (priceData.price > 0) {
                    prices[minutesBack - 1 - i] = uint256(uint64(priceData.price));
                }
            } catch {
                prices[minutesBack - 1 - i] = 0; // æ ‡è®°ä¸ºæ— æ•ˆä»·æ ¼
            }
        }
    }
    
    /// @notice æ£€æŸ¥æŒ‡å®šæ—¶é—´æ˜¯å¦æœ‰ä»·æ ¼æ•°æ®
    /// @param targetTimestamp ç›®æ ‡æ—¶é—´æˆ³
    /// @return hasPrice æ˜¯å¦æœ‰ä»·æ ¼æ•°æ®
    /// @return priceAge ä»·æ ¼å¹´é¾„ï¼ˆç§’ï¼‰
    function checkPriceAvailability(uint256 targetTimestamp) external view returns (
        bool hasPrice, 
        uint256 priceAge
    ) {
        require(targetTimestamp % 60 == 0, "Timestamp must be minute-aligned");
        
        try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, targetTimestamp) returns (IPyth.Price memory priceData) {
            if (priceData.publishTime == targetTimestamp && priceData.price > 0) {
                priceAge = block.timestamp - targetTimestamp;
                return (true, priceAge);
            }
        } catch {
            // ä»·æ ¼ä¸å­˜åœ¨
        }
        
        return (false, 0);
    }
}
```

### 2. é¢„æµ‹å¸‚åœºç»“ç®—åˆçº¦

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./IPyth.sol";

contract PredictionMarketSettlement {
    IPyth public immutable pyth;
    bytes32 public constant BTC_FEED_ID = 0x7404e3d104ea7841c3d9e6fd20adfe99b4ad586bc08d8f3bd3afef894cf184de;
    
    struct Prediction {
        uint256 settlementTime;    // ç»“ç®—æ—¶é—´ï¼ˆæ•´åˆ†é’Ÿï¼‰
        uint256 targetPrice;       // é¢„æµ‹ä»·æ ¼
        address predictor;         // é¢„æµ‹è€…
        bool settled;              // æ˜¯å¦å·²ç»“ç®—
        bool won;                  // æ˜¯å¦è·èƒœ
        uint256 actualPrice;       // å®é™…ç»“ç®—ä»·æ ¼
    }
    
    mapping(uint256 => Prediction) public predictions;
    uint256 public nextPredictionId;
    
    event PredictionCreated(uint256 indexed predictionId, address indexed predictor, uint256 settlementTime, uint256 targetPrice);
    event PredictionSettled(uint256 indexed predictionId, uint256 actualPrice, bool won);
    
    constructor(address _pyth) {
        pyth = IPyth(_pyth);
    }
    
    /// @notice åˆ›å»ºä»·æ ¼é¢„æµ‹
    /// @param settlementTime ç»“ç®—æ—¶é—´ï¼ˆå¿…é¡»ä¸ºæ•´åˆ†é’Ÿï¼‰
    /// @param targetPrice é¢„æµ‹ä»·æ ¼ï¼ˆUSDï¼Œ8ä½å°æ•°ï¼‰
    function createPrediction(uint256 settlementTime, uint256 targetPrice) external {
        require(settlementTime % 60 == 0, "Settlement time must be minute-aligned");
        require(settlementTime > block.timestamp, "Settlement time must be in future");
        require(targetPrice > 0, "Target price must be positive");
        
        uint256 predictionId = nextPredictionId++;
        predictions[predictionId] = Prediction({
            settlementTime: settlementTime,
            targetPrice: targetPrice,
            predictor: msg.sender,
            settled: false,
            won: false,
            actualPrice: 0
        });
        
        emit PredictionCreated(predictionId, msg.sender, settlementTime, targetPrice);
    }
    
    /// @notice ç»“ç®—é¢„æµ‹ï¼ˆä½¿ç”¨å½“å‰ä»·æ ¼ï¼‰
    /// @param predictionId é¢„æµ‹ID
    function settlePrediction(uint256 predictionId) external {
        Prediction storage prediction = predictions[predictionId];
        require(!prediction.settled, "Prediction already settled");
        require(block.timestamp >= prediction.settlementTime + 60, "Settlement time not reached");
        
        // è·å–ç»“ç®—æ—¶é—´çš„ä»·æ ¼
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        // éªŒè¯ä»·æ ¼æ—¶é—´æˆ³æ˜¯å¦åŒ¹é…ç»“ç®—æ—¶é—´
        require(priceData.publishTime == prediction.settlementTime, "Price timestamp mismatch");
        
        uint256 actualPrice = uint256(uint64(priceData.price));
        
        // åˆ¤æ–­é¢„æµ‹æ˜¯å¦æ­£ç¡®ï¼ˆå…è®¸1%è¯¯å·®ï¼‰
        uint256 tolerance = actualPrice / 100; // 1%å®¹å·®
        bool won = actualPrice >= prediction.targetPrice - tolerance && 
                   actualPrice <= prediction.targetPrice + tolerance;
        
        prediction.settled = true;
        prediction.won = won;
        prediction.actualPrice = actualPrice;
        
        emit PredictionSettled(predictionId, actualPrice, won);
    }
    
    // ==================== V2 æ–°å¢ï¼šå†å²ä»·æ ¼ç»“ç®—åŠŸèƒ½ ====================
    
    /// @notice ä½¿ç”¨å†å²ä»·æ ¼ç»“ç®—é¢„æµ‹ â­ æ ¸å¿ƒåŠŸèƒ½
    /// @dev è¿™æ˜¯é¢„æµ‹å¸‚åœºçš„æ ¸å¿ƒåŠŸèƒ½ï¼Œä½¿ç”¨ç²¾ç¡®çš„å†å²æ•´åˆ†ä»·æ ¼è¿›è¡Œç»“ç®—
    /// @param predictionId é¢„æµ‹ID
    function settleWithHistoricalPrice(uint256 predictionId) external {
        Prediction storage prediction = predictions[predictionId];
        require(!prediction.settled, "Prediction already settled");
        require(block.timestamp >= prediction.settlementTime + 60, "Wait for price confirmation");
        
        // ä½¿ç”¨ getPriceAtZeroTimestamp è·å–ç²¾ç¡®çš„å†å²ä»·æ ¼
        IPyth.Price memory historicalPrice = pyth.getPriceAtZeroTimestamp(
            BTC_FEED_ID, 
            prediction.settlementTime
        );
        
        // éªŒè¯å†å²ä»·æ ¼çš„æœ‰æ•ˆæ€§
        require(historicalPrice.publishTime == prediction.settlementTime, "Historical price timestamp mismatch");
        require(historicalPrice.price > 0, "Invalid historical price");
        
        uint256 actualPrice = uint256(uint64(historicalPrice.price));
        
        // åˆ¤æ–­é¢„æµ‹ç»“æœï¼ˆå…è®¸1%è¯¯å·®ï¼‰
        uint256 tolerance = actualPrice / 100;
        bool won = actualPrice >= prediction.targetPrice - tolerance && 
                   actualPrice <= prediction.targetPrice + tolerance;
        
        prediction.settled = true;
        prediction.won = won;
        prediction.actualPrice = actualPrice;
        
        emit PredictionSettled(predictionId, actualPrice, won);
    }
    
    /// @notice æ‰¹é‡ç»“ç®—å¤šä¸ªé¢„æµ‹
    /// @param predictionIds é¢„æµ‹IDæ•°ç»„
    function batchSettleWithHistoricalPrice(uint256[] calldata predictionIds) external {
        for (uint256 i = 0; i < predictionIds.length; i++) {
            uint256 predictionId = predictionIds[i];
            Prediction storage prediction = predictions[predictionId];
            
            // è·³è¿‡å·²ç»“ç®—æˆ–æ—¶é—´æœªåˆ°çš„é¢„æµ‹
            if (prediction.settled || block.timestamp < prediction.settlementTime + 60) {
                continue;
            }
            
            try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, prediction.settlementTime) returns (IPyth.Price memory historicalPrice) {
                if (historicalPrice.publishTime == prediction.settlementTime && historicalPrice.price > 0) {
                    uint256 actualPrice = uint256(uint64(historicalPrice.price));
                    uint256 tolerance = actualPrice / 100;
                    bool won = actualPrice >= prediction.targetPrice - tolerance && 
                               actualPrice <= prediction.targetPrice + tolerance;
                    
                    prediction.settled = true;
                    prediction.won = won;
                    prediction.actualPrice = actualPrice;
                    
                    emit PredictionSettled(predictionId, actualPrice, won);
                }
            } catch {
                // å†å²ä»·æ ¼ä¸å¯ç”¨ï¼Œè·³è¿‡æ­¤é¢„æµ‹
                continue;
            }
        }
    }
    
    /// @notice æ£€æŸ¥é¢„æµ‹æ˜¯å¦å¯ä»¥ç»“ç®—
    /// @param predictionId é¢„æµ‹ID
    /// @return canSettle æ˜¯å¦å¯ä»¥ç»“ç®—
    /// @return reason ä¸èƒ½ç»“ç®—çš„åŸå› 
    function canSettlePrediction(uint256 predictionId) external view returns (
        bool canSettle, 
        string memory reason
    ) {
        Prediction storage prediction = predictions[predictionId];
        
        if (prediction.settled) {
            return (false, "Already settled");
        }
        
        if (block.timestamp < prediction.settlementTime + 60) {
            return (false, "Settlement time not reached");
        }
        
        // æ£€æŸ¥å†å²ä»·æ ¼æ˜¯å¦å¯ç”¨
        try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, prediction.settlementTime) returns (IPyth.Price memory historicalPrice) {
            if (historicalPrice.publishTime == prediction.settlementTime && historicalPrice.price > 0) {
                return (true, "Ready to settle");
            } else {
                return (false, "Historical price not available or invalid");
            }
        } catch {
            return (false, "Historical price not found");
        }
    }
    
    /// @notice è·å–é¢„æµ‹çš„å†å²ä»·æ ¼ï¼ˆç”¨äºé¢„è§ˆï¼‰
    /// @param predictionId é¢„æµ‹ID
    /// @return price å†å²ä»·æ ¼
    /// @return available ä»·æ ¼æ˜¯å¦å¯ç”¨
    function getHistoricalPriceForPrediction(uint256 predictionId) external view returns (
        uint256 price, 
        bool available
    ) {
        Prediction storage prediction = predictions[predictionId];
        
        try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, prediction.settlementTime) returns (IPyth.Price memory historicalPrice) {
            if (historicalPrice.publishTime == prediction.settlementTime && historicalPrice.price > 0) {
                return (uint256(uint64(historicalPrice.price)), true);
            }
        } catch {
            // ä»·æ ¼ä¸å¯ç”¨
        }
        
        return (0, false);
    }
    
    /// @notice è·å–æŒ‡å®šæ—¶é—´çš„ä»·æ ¼ï¼ˆç”¨äºéªŒè¯ï¼‰
    /// @param targetTime ç›®æ ‡æ—¶é—´ï¼ˆæ•´åˆ†é’Ÿï¼‰
    /// @return price ä»·æ ¼
    /// @return isAvailable ä»·æ ¼æ˜¯å¦å¯ç”¨
    function getPriceAtTime(uint256 targetTime) external view returns (uint256 price, bool isAvailable) {
        require(targetTime % 60 == 0, "Target time must be minute-aligned");
        
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        if (priceData.publishTime == targetTime) {
            return (uint256(uint64(priceData.price)), true);
        } else {
            return (0, false);
        }
    }
}
```

### 3. æœŸæƒåˆçº¦ç¤ºä¾‹

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./IPyth.sol";

contract BTCOption {
    IPyth public immutable pyth;
    bytes32 public constant BTC_FEED_ID = 0x7404e3d104ea7841c3d9e6fd20adfe99b4ad586bc08d8f3bd3afef894cf184de;
    
    struct Option {
        uint256 strikePrice;       // è¡Œæƒä»·æ ¼ï¼ˆUSDï¼Œ8ä½å°æ•°ï¼‰
        uint256 expiryTime;        // åˆ°æœŸæ—¶é—´ï¼ˆæ•´åˆ†é’Ÿï¼‰
        uint256 premium;           // æœŸæƒè´¹
        address buyer;             // ä¹°æ–¹
        address seller;            // å–æ–¹
        bool exercised;            // æ˜¯å¦å·²è¡Œæƒ
        bool settled;              // æ˜¯å¦å·²ç»“ç®—
        OptionType optionType;     // æœŸæƒç±»å‹
    }
    
    enum OptionType { CALL, PUT }
    
    mapping(uint256 => Option) public options;
    uint256 public nextOptionId;
    
    event OptionCreated(uint256 indexed optionId, address indexed buyer, address indexed seller, uint256 strikePrice, uint256 expiryTime);
    event OptionExercised(uint256 indexed optionId, uint256 spotPrice, uint256 payout);
    
    constructor(address _pyth) {
        pyth = IPyth(_pyth);
    }
    
    /// @notice åˆ›å»ºæœŸæƒ
    /// @param strikePrice è¡Œæƒä»·æ ¼
    /// @param expiryTime åˆ°æœŸæ—¶é—´ï¼ˆæ•´åˆ†é’Ÿï¼‰
    /// @param optionType æœŸæƒç±»å‹
    function createOption(
        uint256 strikePrice,
        uint256 expiryTime,
        OptionType optionType
    ) external payable {
        require(expiryTime % 60 == 0, "Expiry time must be minute-aligned");
        require(expiryTime > block.timestamp, "Expiry time must be in future");
        require(strikePrice > 0, "Strike price must be positive");
        require(msg.value > 0, "Premium must be positive");
        
        uint256 optionId = nextOptionId++;
        options[optionId] = Option({
            strikePrice: strikePrice,
            expiryTime: expiryTime,
            premium: msg.value,
            buyer: msg.sender,
            seller: address(0), // éœ€è¦å•ç‹¬è®¾ç½®å–æ–¹
            exercised: false,
            settled: false,
            optionType: optionType
        });
        
        emit OptionCreated(optionId, msg.sender, address(0), strikePrice, expiryTime);
    }
    
    /// @notice è¡ŒæƒæœŸæƒ
    /// @param optionId æœŸæƒID
    function exerciseOption(uint256 optionId) external {
        Option storage option = options[optionId];
        require(msg.sender == option.buyer, "Only buyer can exercise");
        require(!option.exercised, "Option already exercised");
        require(block.timestamp >= option.expiryTime, "Option not yet expired");
        require(block.timestamp < option.expiryTime + 300, "Exercise window closed"); // 5åˆ†é’Ÿè¡Œæƒçª—å£
        
        // è·å–åˆ°æœŸæ—¶é—´çš„ä»·æ ¼
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        require(priceData.publishTime == option.expiryTime, "Price not available for expiry time");
        
        uint256 spotPrice = uint256(uint64(priceData.price));
        uint256 payout = 0;
        
        if (option.optionType == OptionType.CALL) {
            // çœ‹æ¶¨æœŸæƒï¼šç°ä»· > è¡Œæƒä»·æ—¶æœ‰ä»·å€¼
            if (spotPrice > option.strikePrice) {
                payout = spotPrice - option.strikePrice;
            }
        } else {
            // çœ‹è·ŒæœŸæƒï¼šç°ä»· < è¡Œæƒä»·æ—¶æœ‰ä»·å€¼
            if (spotPrice < option.strikePrice) {
                payout = option.strikePrice - spotPrice;
            }
        }
        
        option.exercised = true;
        option.settled = true;
        
        if (payout > 0) {
            // å®é™…å®ç°ä¸­éœ€è¦è€ƒè™‘èµ„é‡‘æ± å’Œç»“ç®—æœºåˆ¶
            payable(option.buyer).transfer(payout);
        }
        
        emit OptionExercised(optionId, spotPrice, payout);
    }
    
    /// @notice æ£€æŸ¥æœŸæƒæ˜¯å¦å¯ä»¥è¡Œæƒ
    /// @param optionId æœŸæƒID
    /// @return canExercise æ˜¯å¦å¯ä»¥è¡Œæƒ
    /// @return spotPrice å½“å‰ä»·æ ¼
    /// @return intrinsicValue å†…åœ¨ä»·å€¼
    function checkExercisability(uint256 optionId) external view returns (
        bool canExercise,
        uint256 spotPrice,
        uint256 intrinsicValue
    ) {
        Option storage option = options[optionId];
        
        if (option.exercised || block.timestamp < option.expiryTime) {
            return (false, 0, 0);
        }
        
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        if (priceData.publishTime != option.expiryTime) {
            return (false, 0, 0);
        }
        
        spotPrice = uint256(uint64(priceData.price));
        
        if (option.optionType == OptionType.CALL) {
            intrinsicValue = spotPrice > option.strikePrice ? spotPrice - option.strikePrice : 0;
        } else {
            intrinsicValue = spotPrice < option.strikePrice ? option.strikePrice - spotPrice : 0;
        }
        
        canExercise = intrinsicValue > 0;
    }
}
```

## ä»·æ ¼å¤„ç†å·¥å…·åº“

### PriceUtils åº“

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./IPyth.sol";

library PriceUtils {
    /// @notice å°†Pythä»·æ ¼è½¬æ¢ä¸ºUSDæ ¼å¼
    /// @param priceData Pythä»·æ ¼æ•°æ®
    /// @return priceInUSD USDä»·æ ¼ï¼ˆå»é™¤å°æ•°ä½ï¼‰
    function toUSD(IPyth.Price memory priceData) internal pure returns (uint256 priceInUSD) {
        require(priceData.price > 0, "Invalid price");
        require(priceData.expo == -8, "Unexpected price exponent");
        
        return uint256(uint64(priceData.price)) / 1e8;
    }
    
    /// @notice å°†Pythä»·æ ¼è½¬æ¢ä¸ºå¸¦å°æ•°çš„USDæ ¼å¼
    /// @param priceData Pythä»·æ ¼æ•°æ®
    /// @return priceWithDecimals å¸¦8ä½å°æ•°çš„ä»·æ ¼
    function toUSDWithDecimals(IPyth.Price memory priceData) internal pure returns (uint256 priceWithDecimals) {
        require(priceData.price > 0, "Invalid price");
        require(priceData.expo == -8, "Unexpected price exponent");
        
        return uint256(uint64(priceData.price));
    }
    
    /// @notice éªŒè¯ä»·æ ¼æ—¶é—´æˆ³æ˜¯å¦ä¸ºæ•´åˆ†é’Ÿï¼ˆæ ¸å¿ƒå‡½æ•°ï¼‰
    /// @param priceData Pythä»·æ ¼æ•°æ®
    /// @return isMinuteAligned æ˜¯å¦ä¸ºæ•´åˆ†é’Ÿå¯¹é½
    function isMinuteAligned(IPyth.Price memory priceData) internal pure returns (bool isMinuteAligned) {
        return priceData.publishTime % 60 == 0;
    }
    
    /// @notice éªŒè¯æ˜¯å¦ä¸ºæœ‰æ•ˆçš„æ•´åˆ†ä»·æ ¼ï¼ˆå®Œæ•´éªŒè¯ï¼‰
    /// @param priceData Pythä»·æ ¼æ•°æ®
    /// @return isValid æ˜¯å¦ä¸ºæœ‰æ•ˆçš„æ•´åˆ†ä»·æ ¼
    function isValidMinutePrice(IPyth.Price memory priceData) internal pure returns (bool isValid) {
        return priceData.price > 0 && 
               priceData.expo == -8 && 
               priceData.publishTime % 60 == 0;
    }
    
    /// @notice è·å–æŒ‡å®šæ—¶é—´æˆ³çš„æ•´åˆ†é’Ÿæ—¶é—´æˆ³
    /// @param timestamp ä»»æ„æ—¶é—´æˆ³
    /// @return minuteTimestamp å¯¹åº”çš„æ•´åˆ†é’Ÿæ—¶é—´æˆ³
    function toMinuteTimestamp(uint256 timestamp) internal pure returns (uint256 minuteTimestamp) {
        return (timestamp / 60) * 60;
    }
    
    /// @notice æ£€æŸ¥ä»·æ ¼æ˜¯å¦ä¸ºæŒ‡å®šåˆ†é’Ÿçš„ä»·æ ¼
    /// @param priceData Pythä»·æ ¼æ•°æ®
    /// @param targetMinute ç›®æ ‡åˆ†é’Ÿæ—¶é—´æˆ³
    /// @return isMatch æ˜¯å¦åŒ¹é…
    function isPriceForMinute(IPyth.Price memory priceData, uint256 targetMinute) internal pure returns (bool isMatch) {
        require(targetMinute % 60 == 0, "Target minute must be minute-aligned");
        return priceData.publishTime == targetMinute;
    }
    
    /// @notice éªŒè¯æ•´åˆ†ä»·æ ¼çš„æ—¶æ•ˆæ€§
    /// @param priceData Pythä»·æ ¼æ•°æ®
    /// @param maxAgeMinutes æœ€å¤§å…è®¸å¹´é¾„ï¼ˆåˆ†é’Ÿï¼‰
    /// @return isRecent æ˜¯å¦åœ¨æ—¶æ•ˆèŒƒå›´å†…
    function isRecentMinutePrice(IPyth.Price memory priceData, uint256 maxAgeMinutes) internal view returns (bool isRecent) {
        require(priceData.publishTime % 60 == 0, "Price not minute-aligned");
        return (block.timestamp - priceData.publishTime) <= (maxAgeMinutes * 60);
    }
    
    /// @notice æ£€æŸ¥ä»·æ ¼æ˜¯å¦ä¸è¶…è¿‡æŒ‡å®šå¹´é¾„
    /// @param priceData Pythä»·æ ¼æ•°æ®
    /// @param maxAge æœ€å¤§å¹´é¾„ï¼ˆç§’ï¼‰
    /// @return isRecent æ˜¯å¦ä¸ºæœ€è¿‘ä»·æ ¼
    function isRecent(IPyth.Price memory priceData, uint256 maxAge) internal view returns (bool isRecent) {
        return (block.timestamp - priceData.publishTime) <= maxAge;
    }
    
    /// @notice è®¡ç®—ä»·æ ¼å˜åŒ–ç™¾åˆ†æ¯”
    /// @param oldPrice æ—§ä»·æ ¼
    /// @param newPrice æ–°ä»·æ ¼
    /// @return changePercent å˜åŒ–ç™¾åˆ†æ¯”ï¼ˆåŸºç‚¹ï¼Œ10000 = 100%ï¼‰
    function calculatePriceChange(uint256 oldPrice, uint256 newPrice) internal pure returns (int256 changePercent) {
        require(oldPrice > 0, "Old price must be positive");
        
        if (newPrice >= oldPrice) {
            return int256(((newPrice - oldPrice) * 10000) / oldPrice);
        } else {
            return -int256(((oldPrice - newPrice) * 10000) / oldPrice);
        }
    }
    
    /// @notice æ£€æŸ¥ä»·æ ¼æ˜¯å¦åœ¨æŒ‡å®šèŒƒå›´å†…
    /// @param price ä»·æ ¼
    /// @param target ç›®æ ‡ä»·æ ¼
    /// @param tolerancePercent å®¹å·®ç™¾åˆ†æ¯”ï¼ˆåŸºç‚¹ï¼Œ100 = 1%ï¼‰
    /// @return inRange æ˜¯å¦åœ¨èŒƒå›´å†…
    function isPriceInRange(uint256 price, uint256 target, uint256 tolerancePercent) internal pure returns (bool inRange) {
        uint256 tolerance = (target * tolerancePercent) / 10000;
        return price >= target - tolerance && price <= target + tolerance;
    }
}
```

## å®‰å…¨è€ƒè™‘

### 1. ä»·æ ¼éªŒè¯

```solidity
contract SecurePriceConsumer {
    IPyth public immutable pyth;
    bytes32 public constant BTC_FEED_ID = 0x7404e3d104ea7841c3d9e6fd20adfe99b4ad586bc08d8f3bd3afef894cf184de;
    
    uint256 public constant MAX_PRICE_AGE = 300; // 5åˆ†é’Ÿ
    uint256 public constant MIN_PRICE = 1000 * 1e8; // $1,000
    uint256 public constant MAX_PRICE = 1000000 * 1e8; // $1,000,000
    
    modifier validPrice(IPyth.Price memory priceData) {
        require(priceData.price > 0, "Price must be positive");
        require(priceData.expo == -8, "Invalid price exponent");
        require(priceData.publishTime % 60 == 0, "Price not minute-aligned");
        require(block.timestamp - priceData.publishTime <= MAX_PRICE_AGE, "Price too old");
        require(uint256(uint64(priceData.price)) >= MIN_PRICE, "Price too low");
        require(uint256(uint64(priceData.price)) <= MAX_PRICE, "Price too high");
        _;
    }
    
    function getValidatedPrice() external view returns (uint256 price, uint256 timestamp) {
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        // åº”ç”¨ä»·æ ¼éªŒè¯
        require(priceData.price > 0, "Price must be positive");
        require(priceData.expo == -8, "Invalid price exponent");
        require(priceData.publishTime % 60 == 0, "Price not minute-aligned");
        require(block.timestamp - priceData.publishTime <= MAX_PRICE_AGE, "Price too old");
        require(uint256(uint64(priceData.price)) >= MIN_PRICE, "Price too low");
        require(uint256(uint64(priceData.price)) <= MAX_PRICE, "Price too high");
        
        return (uint256(uint64(priceData.price)), priceData.publishTime);
    }
}
```

### 2. é‡å…¥æ”»å‡»é˜²æŠ¤

```solidity
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract SecureOptionContract is ReentrancyGuard {
    // ä½¿ç”¨ nonReentrant ä¿®é¥°ç¬¦ä¿æŠ¤å…³é”®å‡½æ•°
    function exerciseOption(uint256 optionId) external nonReentrant {
        // æœŸæƒè¡Œæƒé€»è¾‘
    }
}
```

## Gas ä¼˜åŒ–å»ºè®®

### 1. æ‰¹é‡ä»·æ ¼æŸ¥è¯¢

```solidity
contract BatchPriceConsumer {
    IPyth public immutable pyth;
    
    struct PriceInfo {
        uint256 price;
        uint256 timestamp;
        bool valid;
    }
    
    /// @notice æ‰¹é‡è·å–å¤šä¸ªæ—¶é—´ç‚¹çš„ä»·æ ¼
    /// @param targetTimes ç›®æ ‡æ—¶é—´æ•°ç»„ï¼ˆæ•´åˆ†é’Ÿï¼‰
    /// @return prices ä»·æ ¼ä¿¡æ¯æ•°ç»„
    function getBatchPrices(uint256[] calldata targetTimes) external view returns (PriceInfo[] memory prices) {
        prices = new PriceInfo[](targetTimes.length);
        IPyth.Price memory currentPrice = pyth.getPrice(BTC_FEED_ID);
        
        for (uint256 i = 0; i < targetTimes.length; i++) {
            if (currentPrice.publishTime == targetTimes[i]) {
                prices[i] = PriceInfo({
                    price: uint256(uint64(currentPrice.price)),
                    timestamp: currentPrice.publishTime,
                    valid: true
                });
            } else {
                prices[i] = PriceInfo({
                    price: 0,
                    timestamp: 0,
                    valid: false
                });
            }
        }
    }
}
```

### 2. ä»·æ ¼ç¼“å­˜

```solidity
contract CachedPriceConsumer {
    IPyth public immutable pyth;
    
    struct CachedPrice {
        uint256 price;
        uint256 timestamp;
        uint256 blockNumber;
    }
    
    mapping(bytes32 => CachedPrice) private priceCache;
    
    /// @notice è·å–ç¼“å­˜çš„ä»·æ ¼ï¼ˆåŒä¸€åŒºå—å†…å¤ç”¨ï¼‰
    function getCachedPrice(bytes32 feedId) external view returns (uint256 price, uint256 timestamp) {
        CachedPrice memory cached = priceCache[feedId];
        
        if (cached.blockNumber == block.number) {
            return (cached.price, cached.timestamp);
        }
        
        IPyth.Price memory priceData = pyth.getPrice(feedId);
        return (uint256(uint64(priceData.price)), priceData.publishTime);
    }
    
    /// @notice æ›´æ–°ä»·æ ¼ç¼“å­˜
    function updatePriceCache(bytes32 feedId) external {
        IPyth.Price memory priceData = pyth.getPrice(feedId);
        
        priceCache[feedId] = CachedPrice({
            price: uint256(uint64(priceData.price)),
            timestamp: priceData.publishTime,
            blockNumber: block.number
        });
    }
}
```

## V2 å†å²ä»·æ ¼æŸ¥è¯¢æœ€ä½³å®è·µ

### 1. getPriceAtZeroTimestamp æ ¸å¿ƒä½¿ç”¨æ¨¡å¼

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./IPyth.sol";

contract HistoricalPriceBestPractices {
    IPyth public immutable pyth;
    bytes32 public constant BTC_FEED_ID = 0x7404e3d104ea7841c3d9e6fd20adfe99b4ad586bc08d8f3bd3afef894cf184de;
    
    /// @notice å®‰å…¨è·å–å†å²ä»·æ ¼çš„æ ‡å‡†æ¨¡å¼ â­ æ¨è
    /// @param timestamp æ•´åˆ†é’Ÿæ—¶é—´æˆ³
    /// @return price ä»·æ ¼
    /// @return success æ˜¯å¦æˆåŠŸè·å–
    function safeGetHistoricalPrice(uint256 timestamp) public view returns (uint256 price, bool success) {
        // 1. éªŒè¯æ—¶é—´æˆ³æ ¼å¼
        if (timestamp % 60 != 0) {
            return (0, false);
        }
        
        // 2. éªŒè¯æ—¶é—´èŒƒå›´ï¼ˆä¸èƒ½æ˜¯æœªæ¥æ—¶é—´ï¼‰
        if (timestamp > block.timestamp) {
            return (0, false);
        }
        
        // 3. å®‰å…¨è°ƒç”¨ getPriceAtZeroTimestamp
        try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, timestamp) returns (IPyth.Price memory priceData) {
            // 4. éªŒè¯è¿”å›çš„ä»·æ ¼æ•°æ®
            if (priceData.publishTime == timestamp && priceData.price > 0) {
                return (uint256(uint64(priceData.price)), true);
            }
        } catch {
            // ä»·æ ¼ä¸å­˜åœ¨æˆ–æŸ¥è¯¢å¤±è´¥
        }
        
        return (0, false);
    }
    
    /// @notice æ‰¹é‡è·å–å†å²ä»·æ ¼ï¼ˆGasä¼˜åŒ–ï¼‰
    /// @param timestamps æ—¶é—´æˆ³æ•°ç»„
    /// @return prices ä»·æ ¼æ•°ç»„
    /// @return successes æˆåŠŸæ ‡å¿—æ•°ç»„
    function batchGetHistoricalPrices(uint256[] calldata timestamps) external view returns (
        uint256[] memory prices,
        bool[] memory successes
    ) {
        prices = new uint256[](timestamps.length);
        successes = new bool[](timestamps.length);
        
        for (uint256 i = 0; i < timestamps.length; i++) {
            (prices[i], successes[i]) = safeGetHistoricalPrice(timestamps[i]);
        }
    }
    
    /// @notice è·å–æ—¶é—´èŒƒå›´å†…çš„å†å²ä»·æ ¼
    /// @param startTime å¼€å§‹æ—¶é—´ï¼ˆæ•´åˆ†é’Ÿï¼‰
    /// @param endTime ç»“æŸæ—¶é—´ï¼ˆæ•´åˆ†é’Ÿï¼‰
    /// @return timestamps æ—¶é—´æˆ³æ•°ç»„
    /// @return prices ä»·æ ¼æ•°ç»„
    function getHistoricalPriceRange(uint256 startTime, uint256 endTime) external view returns (
        uint256[] memory timestamps,
        uint256[] memory prices
    ) {
        require(startTime % 60 == 0 && endTime % 60 == 0, "Times must be minute-aligned");
        require(startTime <= endTime, "Invalid time range");
        require(endTime <= block.timestamp, "End time cannot be in future");
        
        uint256 count = (endTime - startTime) / 60 + 1;
        require(count <= 100, "Range too large"); // é™åˆ¶æœ€å¤§æŸ¥è¯¢èŒƒå›´
        
        timestamps = new uint256[](count);
        prices = new uint256[](count);
        
        uint256 validCount = 0;
        for (uint256 i = 0; i < count; i++) {
            uint256 timestamp = startTime + (i * 60);
            (uint256 price, bool success) = safeGetHistoricalPrice(timestamp);
            
            if (success) {
                timestamps[validCount] = timestamp;
                prices[validCount] = price;
                validCount++;
            }
        }
        
        // è°ƒæ•´æ•°ç»„å¤§å°
        assembly {
            mstore(timestamps, validCount)
            mstore(prices, validCount)
        }
    }
}
```

### 2. é¢„æµ‹å¸‚åœºä¸“ç”¨å†å²ä»·æ ¼æ¨¡å¼

```solidity
contract PredictionMarketHistoricalPrice {
    IPyth public immutable pyth;
    
    /// @notice é¢„æµ‹å¸‚åœºç»“ç®—ä¸“ç”¨æ¨¡å¼
    /// @param feedId ä»·æ ¼æºID
    /// @param settlementTime ç»“ç®—æ—¶é—´
    /// @param gracePeriod å®½é™æœŸï¼ˆç§’ï¼‰
    /// @return price ç»“ç®—ä»·æ ¼
    /// @return isValid æ˜¯å¦æœ‰æ•ˆ
    function getSettlementPrice(
        bytes32 feedId,
        uint256 settlementTime,
        uint256 gracePeriod
    ) external view returns (uint256 price, bool isValid) {
        // 1. éªŒè¯ç»“ç®—æ—¶é—´å¿…é¡»æ˜¯æ•´åˆ†é’Ÿ
        require(settlementTime % 60 == 0, "Settlement time must be minute-aligned");
        
        // 2. ç¡®ä¿å·²è¿‡ç»“ç®—æ—¶é—´ + å®½é™æœŸ
        require(block.timestamp >= settlementTime + gracePeriod, "Settlement not ready");
        
        // 3. è·å–ç²¾ç¡®çš„å†å²ä»·æ ¼
        try pyth.getPriceAtZeroTimestamp(feedId, settlementTime) returns (IPyth.Price memory priceData) {
            if (priceData.publishTime == settlementTime && priceData.price > 0) {
                return (uint256(uint64(priceData.price)), true);
            }
        } catch {
            // å†å²ä»·æ ¼ä¸å¯ç”¨
        }
        
        return (0, false);
    }
    
    /// @notice æ£€æŸ¥ç»“ç®—ä»·æ ¼å¯ç”¨æ€§
    /// @param feedId ä»·æ ¼æºID
    /// @param settlementTime ç»“ç®—æ—¶é—´
    /// @return available æ˜¯å¦å¯ç”¨
    /// @return waitTime éœ€è¦ç­‰å¾…çš„æ—¶é—´ï¼ˆç§’ï¼‰
    function checkSettlementAvailability(
        bytes32 feedId,
        uint256 settlementTime
    ) external view returns (bool available, uint256 waitTime) {
        require(settlementTime % 60 == 0, "Settlement time must be minute-aligned");
        
        if (block.timestamp < settlementTime) {
            return (false, settlementTime - block.timestamp);
        }
        
        // æ£€æŸ¥å†å²ä»·æ ¼æ˜¯å¦å·²å¯ç”¨
        try pyth.getPriceAtZeroTimestamp(feedId, settlementTime) returns (IPyth.Price memory priceData) {
            if (priceData.publishTime == settlementTime && priceData.price > 0) {
                return (true, 0);
            }
        } catch {
            // ä»·æ ¼å¯èƒ½è¿˜æœªä¸Šä¼ ï¼Œå»ºè®®ç­‰å¾…
        }
        
        // å»ºè®®ç­‰å¾…æ—¶é—´ï¼šç»“ç®—æ—¶é—´å60ç§’
        uint256 recommendedWaitTime = settlementTime + 60;
        if (block.timestamp < recommendedWaitTime) {
            return (false, recommendedWaitTime - block.timestamp);
        }
        
        return (false, 0); // ä»·æ ¼å¯èƒ½æ°¸ä¹…ä¸å¯ç”¨
    }
}
```

### 3. å†å²ä»·æ ¼ç¼“å­˜ä¼˜åŒ–æ¨¡å¼

```solidity
contract HistoricalPriceCache {
    IPyth public immutable pyth;
    
    struct CachedHistoricalPrice {
        uint256 price;
        bool exists;
        uint256 cachedAt;
    }
    
    // feedId => timestamp => cached price
    mapping(bytes32 => mapping(uint256 => CachedHistoricalPrice)) private historicalCache;
    
    /// @notice å¸¦ç¼“å­˜çš„å†å²ä»·æ ¼æŸ¥è¯¢
    /// @param feedId ä»·æ ¼æºID
    /// @param timestamp æ—¶é—´æˆ³
    /// @return price ä»·æ ¼
    /// @return success æ˜¯å¦æˆåŠŸ
    function getCachedHistoricalPrice(bytes32 feedId, uint256 timestamp) external returns (uint256 price, bool success) {
        require(timestamp % 60 == 0, "Timestamp must be minute-aligned");
        
        // 1. æ£€æŸ¥ç¼“å­˜
        CachedHistoricalPrice storage cached = historicalCache[feedId][timestamp];
        if (cached.cachedAt > 0) {
            return (cached.price, cached.exists);
        }
        
        // 2. æŸ¥è¯¢å†å²ä»·æ ¼
        try pyth.getPriceAtZeroTimestamp(feedId, timestamp) returns (IPyth.Price memory priceData) {
            if (priceData.publishTime == timestamp && priceData.price > 0) {
                // ç¼“å­˜æˆåŠŸç»“æœ
                cached.price = uint256(uint64(priceData.price));
                cached.exists = true;
                cached.cachedAt = block.timestamp;
                return (cached.price, true);
            }
        } catch {
            // æŸ¥è¯¢å¤±è´¥
        }
        
        // 3. ç¼“å­˜å¤±è´¥ç»“æœï¼ˆé¿å…é‡å¤æŸ¥è¯¢ï¼‰
        cached.exists = false;
        cached.cachedAt = block.timestamp;
        return (0, false);
    }
    
    /// @notice é¢„çƒ­å†å²ä»·æ ¼ç¼“å­˜
    /// @param feedId ä»·æ ¼æºID
    /// @param timestamps æ—¶é—´æˆ³æ•°ç»„
    function warmupHistoricalCache(bytes32 feedId, uint256[] calldata timestamps) external {
        for (uint256 i = 0; i < timestamps.length; i++) {
            uint256 timestamp = timestamps[i];
            if (timestamp % 60 != 0) continue;
            
            // è·³è¿‡å·²ç¼“å­˜çš„ä»·æ ¼
            if (historicalCache[feedId][timestamp].cachedAt > 0) continue;
            
            try pyth.getPriceAtZeroTimestamp(feedId, timestamp) returns (IPyth.Price memory priceData) {
                if (priceData.publishTime == timestamp && priceData.price > 0) {
                    historicalCache[feedId][timestamp] = CachedHistoricalPrice({
                        price: uint256(uint64(priceData.price)),
                        exists: true,
                        cachedAt: block.timestamp
                    });
                }
            } catch {
                historicalCache[feedId][timestamp] = CachedHistoricalPrice({
                    price: 0,
                    exists: false,
                    cachedAt: block.timestamp
                });
            }
        }
    }
}
```

## äº‹ä»¶å’Œæ—¥å¿—

### ä»·æ ¼ç›¸å…³äº‹ä»¶å®šä¹‰

```solidity
contract PriceEventEmitter {
    event PriceQueried(
        bytes32 indexed feedId,
        uint256 price,
        uint256 timestamp,
        address indexed caller
    );
    
    event HistoricalPriceQueried(
        bytes32 indexed feedId,
        uint256 indexed timestamp,
        uint256 price,
        address indexed caller
    );
    
    event PriceValidationFailed(
        bytes32 indexed feedId,
        string reason,
        uint256 timestamp
    );
    
    event MinuteAlignedPriceUsed(
        bytes32 indexed feedId,
        uint256 price,
        uint256 minuteTimestamp,
        address indexed user
    );
    
    function queryPriceWithEvent(bytes32 feedId) external {
        IPyth.Price memory priceData = pyth.getPrice(feedId);
        
        emit PriceQueried(
            feedId,
            uint256(uint64(priceData.price)),
            priceData.publishTime,
            msg.sender
        );
        
        if (priceData.publishTime % 60 == 0) {
            emit MinuteAlignedPriceUsed(
                feedId,
                uint256(uint64(priceData.price)),
                priceData.publishTime,
                msg.sender
            );
        }
    }
}
```

## æµ‹è¯•åˆçº¦

### ä»·æ ¼æµ‹è¯•å·¥å…·

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract PriceTestUtils {
    IPyth public immutable pyth;
    bytes32 public constant BTC_FEED_ID = 0x7404e3d104ea7841c3d9e6fd20adfe99b4ad586bc08d8f3bd3afef894cf184de;
    
    constructor(address _pyth) {
        pyth = IPyth(_pyth);
    }
    
    /// @notice æµ‹è¯•ä»·æ ¼æŸ¥è¯¢åŠŸèƒ½
    function testPriceQuery() external view returns (
        uint256 price,
        uint256 timestamp,
        bool isMinuteAligned,
        uint256 ageInSeconds
    ) {
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        return (
            uint256(uint64(priceData.price)),
            priceData.publishTime,
            priceData.publishTime % 60 == 0,
            block.timestamp - priceData.publishTime
        );
    }
    
    /// @notice éªŒè¯æ•´åˆ†ä»·æ ¼æœºåˆ¶
    function verifyMinutePriceMechanism() external view returns (
        bool isValid,
        string memory message
    ) {
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        if (priceData.publishTime % 60 != 0) {
            return (false, "Price timestamp is not minute-aligned");
        }
        
        if (priceData.price <= 0) {
            return (false, "Invalid price value");
        }
        
        if (priceData.expo != -8) {
            return (false, "Unexpected price exponent");
        }
        
        return (true, "Minute price mechanism working correctly");
    }
}
```

## éƒ¨ç½²è„šæœ¬

### Hardhat éƒ¨ç½²è„šæœ¬

```javascript
// scripts/deploy-price-consumer.js
const { ethers } = require("hardhat");

async function main() {
    const PYTH_ORACLE_ADDRESS = "0x132923f95FD7E8a6FD8aC302D8fd92317F23aFfd";
    
    // éƒ¨ç½²ç®€å•ä»·æ ¼æ¶ˆè´¹è€…åˆçº¦
    const SimplePriceConsumer = await ethers.getContractFactory("SimplePriceConsumer");
    const priceConsumer = await SimplePriceConsumer.deploy(PYTH_ORACLE_ADDRESS);
    await priceConsumer.waitForDeployment();
    
    console.log("SimplePriceConsumer deployed to:", await priceConsumer.getAddress());
    
    // æµ‹è¯•ä»·æ ¼æŸ¥è¯¢
    try {
        const [price, timestamp] = await priceConsumer.getBTCPrice();
        console.log("BTC Price:", price.toString());
        console.log("Timestamp:", timestamp.toString());
        console.log("Date:", new Date(Number(timestamp) * 1000).toISOString());
    } catch (error) {
        console.error("Price query failed:", error.message);
    }
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });
```

## æœ€ä½³å®è·µ

### 1. æ•´åˆ†ä»·æ ¼è·å–çš„æœ€ä½³å®è·µ

#### 1.1 æ ‡å‡†æ•´åˆ†ä»·æ ¼éªŒè¯æ¨¡å¼

```solidity
contract MinutePriceBestPractice {
    IPyth public immutable pyth;
    bytes32 public constant BTC_FEED_ID = 0x7404e3d104ea7841c3d9e6fd20adfe99b4ad586bc08d8f3bd3afef894cf184de;
    
    /// @notice æ ‡å‡†æ•´åˆ†ä»·æ ¼è·å–æ¨¡å¼
    modifier onlyValidMinutePrice() {
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        require(priceData.price > 0, "Invalid price");
        require(priceData.expo == -8, "Invalid exponent");
        require(priceData.publishTime % 60 == 0, "Not minute-aligned");
        require(block.timestamp - priceData.publishTime <= 300, "Price too old");
        _;
    }
    
    /// @notice å®‰å…¨çš„æ•´åˆ†ä»·æ ¼è·å–
    function getMinutePriceSafely() external view returns (
        uint256 price,
        uint256 timestamp,
        bool success
    ) {
        try pyth.getPrice(BTC_FEED_ID) returns (IPyth.Price memory priceData) {
            // éªŒè¯æ˜¯å¦ä¸ºæœ‰æ•ˆçš„æ•´åˆ†ä»·æ ¼
            if (priceData.price > 0 && 
                priceData.expo == -8 && 
                priceData.publishTime % 60 == 0 &&
                block.timestamp - priceData.publishTime <= 300) {
                
                return (
                    uint256(uint64(priceData.price)),
                    priceData.publishTime,
                    true
                );
            }
        } catch {
            // å¤„ç†è°ƒç”¨å¤±è´¥
        }
        
        return (0, 0, false);
    }
}
```

#### 1.2 é¢„æµ‹å¸‚åœºä¸“ç”¨æ¨¡å¼

```solidity
contract PredictionMarketBestPractice {
    /// @notice é¢„æµ‹å¸‚åœºç»“ç®—ä¸“ç”¨ä»·æ ¼è·å–
    function getSettlementPrice(uint256 settlementTime) external view returns (
        uint256 price,
        bool available
    ) {
        require(settlementTime % 60 == 0, "Settlement time must be minute-aligned");
        require(settlementTime <= block.timestamp, "Settlement time not reached");
        
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        // ç¡®ä¿ä»·æ ¼æ—¶é—´æˆ³å®Œå…¨åŒ¹é…ç»“ç®—æ—¶é—´
        if (priceData.publishTime == settlementTime && priceData.price > 0) {
            return (uint256(uint64(priceData.price)), true);
        }
        
        return (0, false);
    }
}
```

#### 1.3 æ—¶é—´çª—å£éªŒè¯æ¨¡å¼

```solidity
contract TimeWindowValidation {
    /// @notice éªŒè¯ä»·æ ¼æ˜¯å¦åœ¨æŒ‡å®šæ—¶é—´çª—å£å†…
    function isPriceInTimeWindow(
        uint256 targetMinute,
        uint256 toleranceMinutes
    ) external view returns (bool inWindow, uint256 actualPrice) {
        require(targetMinute % 60 == 0, "Target must be minute-aligned");
        
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        // æ£€æŸ¥ä»·æ ¼æ˜¯å¦åœ¨å®¹å¿æ—¶é—´çª—å£å†…
        uint256 timeDiff = priceData.publishTime > targetMinute ? 
            priceData.publishTime - targetMinute : 
            targetMinute - priceData.publishTime;
            
        if (timeDiff <= toleranceMinutes * 60 && priceData.publishTime % 60 == 0) {
            return (true, uint256(uint64(priceData.price)));
        }
        
        return (false, 0);
    }
}
```

### 2. é”™è¯¯å¤„ç†

```solidity
contract RobustPriceConsumer {
    IPyth public immutable pyth;
    
    enum PriceError {
        NONE,
        FEED_NOT_FOUND,
        PRICE_TOO_OLD,
        INVALID_PRICE,
        NOT_MINUTE_ALIGNED
    }
    
    function getSafeBTCPrice() external view returns (
        uint256 price,
        uint256 timestamp,
        PriceError error
    ) {
        try pyth.getPrice(BTC_FEED_ID) returns (IPyth.Price memory priceData) {
            if (priceData.price <= 0) {
                return (0, 0, PriceError.INVALID_PRICE);
            }
            
            if (priceData.publishTime % 60 != 0) {
                return (0, 0, PriceError.NOT_MINUTE_ALIGNED);
            }
            
            if (block.timestamp - priceData.publishTime > 300) {
                return (0, 0, PriceError.PRICE_TOO_OLD);
            }
            
            return (
                uint256(uint64(priceData.price)),
                priceData.publishTime,
                PriceError.NONE
            );
        } catch {
            return (0, 0, PriceError.FEED_NOT_FOUND);
        }
    }
}
```

### 2. å‡çº§å…¼å®¹æ€§

```solidity
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

contract UpgradeablePriceConsumer is Initializable, OwnableUpgradeable {
    IPyth public pyth;
    
    function initialize(address _pyth) public initializer {
        __Ownable_init();
        pyth = IPyth(_pyth);
    }
    
    function updatePythOracle(address _newPyth) external onlyOwner {
        pyth = IPyth(_newPyth);
    }
}
```

## å¸¸è§é—®é¢˜è§£ç­”

### Q1: getPriceAtZeroTimestamp ä¸ getPrice æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

A: ä¸¤è€…çš„æ ¸å¿ƒåŒºåˆ«åœ¨äºæ•°æ®æ¥æºå’Œç”¨é€”ï¼š

```solidity
contract PriceFunctionComparison {
    IPyth public immutable pyth;
    bytes32 public constant BTC_FEED_ID = 0x7404e3d104ea7841c3d9e6fd20adfe99b4ad586bc08d8f3bd3afef894cf184de;
    
    /// @notice getPrice: è·å–æœ€æ–°ä»·æ ¼ï¼ˆå®æ—¶æ•°æ®ï¼‰
    function getLatestPrice() external view returns (uint256 price, uint256 timestamp) {
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        return (uint256(uint64(priceData.price)), priceData.publishTime);
    }
    
    /// @notice getPriceAtZeroTimestamp: è·å–æŒ‡å®šæ—¶é—´çš„å†å²ä»·æ ¼
    function getHistoricalPrice(uint256 timestamp) external view returns (uint256 price, bool exists) {
        require(timestamp % 60 == 0, "Must be minute-aligned");
        
        try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, timestamp) returns (IPyth.Price memory priceData) {
            if (priceData.publishTime == timestamp && priceData.price > 0) {
                return (uint256(uint64(priceData.price)), true);
            }
        } catch {
            return (0, false);
        }
        
        return (0, false);
    }
}
```

**å…³é”®åŒºåˆ«ï¼š**
- `getPrice()`: è¿”å›æœ€æ–°å¯ç”¨ä»·æ ¼ï¼Œæ—¶é—´æˆ³å¯èƒ½ä¸æ˜¯æ•´åˆ†é’Ÿ
- `getPriceAtZeroTimestamp()`: è¿”å›æŒ‡å®šæ•´åˆ†é’Ÿæ—¶é—´æˆ³çš„ç²¾ç¡®å†å²ä»·æ ¼

### Q2: ä¸ºä»€ä¹ˆ getPriceAtZeroTimestamp æœ‰æ—¶ä¼šå¤±è´¥ï¼Ÿ

A: å¸¸è§å¤±è´¥åŸå› åŠè§£å†³æ–¹æ¡ˆï¼š

```solidity
contract HistoricalPriceErrorHandling {
    enum HistoricalPriceError {
        SUCCESS,
        INVALID_TIMESTAMP,    // æ—¶é—´æˆ³ä¸æ˜¯æ•´åˆ†é’Ÿ
        FUTURE_TIMESTAMP,     // æœªæ¥æ—¶é—´
        PRICE_NOT_AVAILABLE,  // ä»·æ ¼æ•°æ®ä¸å­˜åœ¨
        PRICE_NOT_UPLOADED    // ä»·æ ¼å°šæœªä¸Šä¼ 
    }
    
    /// @notice å¸¦é”™è¯¯å¤„ç†çš„å†å²ä»·æ ¼æŸ¥è¯¢
    function getHistoricalPriceWithError(uint256 timestamp) external view returns (
        uint256 price,
        HistoricalPriceError error
    ) {
        // 1. éªŒè¯æ—¶é—´æˆ³æ ¼å¼
        if (timestamp % 60 != 0) {
            return (0, HistoricalPriceError.INVALID_TIMESTAMP);
        }
        
        // 2. éªŒè¯ä¸æ˜¯æœªæ¥æ—¶é—´
        if (timestamp > block.timestamp) {
            return (0, HistoricalPriceError.FUTURE_TIMESTAMP);
        }
        
        // 3. æŸ¥è¯¢å†å²ä»·æ ¼
        try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, timestamp) returns (IPyth.Price memory priceData) {
            if (priceData.publishTime == timestamp && priceData.price > 0) {
                return (uint256(uint64(priceData.price)), HistoricalPriceError.SUCCESS);
            } else {
                return (0, HistoricalPriceError.PRICE_NOT_AVAILABLE);
            }
        } catch {
            // å¯èƒ½æ˜¯ä»·æ ¼å°šæœªä¸Šä¼ æˆ–æ°¸ä¹…ä¸å­˜åœ¨
            if (block.timestamp < timestamp + 300) { // 5åˆ†é’Ÿå†…
                return (0, HistoricalPriceError.PRICE_NOT_UPLOADED);
            } else {
                return (0, HistoricalPriceError.PRICE_NOT_AVAILABLE);
            }
        }
    }
}
```

### Q3: å¦‚ä½•åœ¨é¢„æµ‹å¸‚åœºä¸­æ­£ç¡®ä½¿ç”¨ getPriceAtZeroTimestampï¼Ÿ

A: é¢„æµ‹å¸‚åœºçš„æœ€ä½³å®è·µæ¨¡å¼ï¼š

```solidity
contract PredictionMarketBestPractice {
    struct Market {
        uint256 settlementTime;  // å¿…é¡»æ˜¯æ•´åˆ†é’Ÿ
        bool settled;
        uint256 settlementPrice;
    }
    
    /// @notice åˆ›å»ºé¢„æµ‹å¸‚åœº
    function createMarket(uint256 _settlementTime) external {
        require(_settlementTime % 60 == 0, "Settlement time must be minute-aligned");
        require(_settlementTime > block.timestamp + 300, "Settlement time too soon");
        
        // åˆ›å»ºå¸‚åœºé€»è¾‘...
    }
    
    /// @notice ç»“ç®—å¸‚åœºï¼ˆæ¨èæ¨¡å¼ï¼‰
    function settleMarket(uint256 marketId) external {
        Market storage market = markets[marketId];
        require(!market.settled, "Already settled");
        
        // ç­‰å¾…å®½é™æœŸï¼Œç¡®ä¿ä»·æ ¼å·²ä¸Šä¼ 
        require(block.timestamp >= market.settlementTime + 60, "Wait for price upload");
        
        // è·å–ç²¾ç¡®çš„ç»“ç®—ä»·æ ¼
        IPyth.Price memory settlementPrice = pyth.getPriceAtZeroTimestamp(
            BTC_FEED_ID, 
            market.settlementTime
        );
        
        require(settlementPrice.publishTime == market.settlementTime, "Price timestamp mismatch");
        require(settlementPrice.price > 0, "Invalid settlement price");
        
        market.settlementPrice = uint256(uint64(settlementPrice.price));
        market.settled = true;
        
        // æ‰§è¡Œç»“ç®—é€»è¾‘...
    }
    
    /// @notice æ£€æŸ¥å¸‚åœºæ˜¯å¦å¯ä»¥ç»“ç®—
    function canSettle(uint256 marketId) external view returns (bool ready, string memory reason) {
        Market storage market = markets[marketId];
        
        if (market.settled) {
            return (false, "Already settled");
        }
        
        if (block.timestamp < market.settlementTime) {
            return (false, "Settlement time not reached");
        }
        
        // æ£€æŸ¥å†å²ä»·æ ¼æ˜¯å¦å¯ç”¨
        try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, market.settlementTime) returns (IPyth.Price memory priceData) {
            if (priceData.publishTime == market.settlementTime && priceData.price > 0) {
                return (true, "Ready to settle");
            } else {
                return (false, "Settlement price not valid");
            }
        } catch {
            if (block.timestamp < market.settlementTime + 300) {
                return (false, "Wait for price upload");
            } else {
                return (false, "Settlement price not available");
            }
        }
    }
}
```

### Q4: getPriceAtZeroTimestamp çš„ Gas æ¶ˆè€—å¦‚ä½•ä¼˜åŒ–ï¼Ÿ

A: Gas ä¼˜åŒ–ç­–ç•¥ï¼š

```solidity
contract GasOptimizedHistoricalPrice {
    // 1. ç¼“å­˜ç­–ç•¥
    mapping(bytes32 => mapping(uint256 => uint256)) private priceCache;
    mapping(bytes32 => mapping(uint256 => bool)) private priceExists;
    
    /// @notice Gasä¼˜åŒ–çš„å†å²ä»·æ ¼æŸ¥è¯¢
    function getOptimizedHistoricalPrice(bytes32 feedId, uint256 timestamp) external returns (uint256 price) {
        // æ£€æŸ¥ç¼“å­˜
        if (priceExists[feedId][timestamp]) {
            return priceCache[feedId][timestamp];
        }
        
        // æŸ¥è¯¢å¹¶ç¼“å­˜
        try pyth.getPriceAtZeroTimestamp(feedId, timestamp) returns (IPyth.Price memory priceData) {
            if (priceData.publishTime == timestamp && priceData.price > 0) {
                price = uint256(uint64(priceData.price));
                priceCache[feedId][timestamp] = price;
                priceExists[feedId][timestamp] = true;
                return price;
            }
        } catch {
            // ç¼“å­˜å¤±è´¥ç»“æœï¼Œé¿å…é‡å¤æŸ¥è¯¢
            priceExists[feedId][timestamp] = true;
            priceCache[feedId][timestamp] = 0;
        }
        
        return 0;
    }
    
    // 2. æ‰¹é‡æŸ¥è¯¢
    function batchGetHistoricalPrices(
        bytes32 feedId,
        uint256[] calldata timestamps
    ) external view returns (uint256[] memory prices, bool[] memory successes) {
        prices = new uint256[](timestamps.length);
        successes = new bool[](timestamps.length);
        
        for (uint256 i = 0; i < timestamps.length; i++) {
            try pyth.getPriceAtZeroTimestamp(feedId, timestamps[i]) returns (IPyth.Price memory priceData) {
                if (priceData.publishTime == timestamps[i] && priceData.price > 0) {
                    prices[i] = uint256(uint64(priceData.price));
                    successes[i] = true;
                }
            } catch {
                // ä¿æŒé»˜è®¤å€¼ (0, false)
            }
        }
    }
    
    // 3. äº‹ä»¶ç›‘å¬ä¼˜åŒ–
    event HistoricalPriceRequested(bytes32 indexed feedId, uint256 indexed timestamp);
    
    function requestHistoricalPrice(bytes32 feedId, uint256 timestamp) external {
        emit HistoricalPriceRequested(feedId, timestamp);
        // é“¾ä¸‹æœåŠ¡å¯ä»¥ç›‘å¬æ­¤äº‹ä»¶ï¼Œé¢„å…ˆå‡†å¤‡ä»·æ ¼æ•°æ®
    }
}
```

### Q5: å¦‚ä½•ç¡®ä¿è·å–çš„æ˜¯æ•´åˆ†é’Ÿä»·æ ¼ï¼Ÿ

A: åœ¨åˆçº¦ä¸­éªŒè¯ `publishTime % 60 == 0`ï¼š

```solidity
function ensureMinutePrice(bytes32 feedId) external view returns (uint256) {
    IPyth.Price memory priceData = pyth.getPrice(feedId);
    require(priceData.publishTime % 60 == 0, "Not a minute-aligned price");
    return uint256(uint64(priceData.price));
}
```

### Q2: æ•´åˆ†ä»·æ ¼çš„æ›´æ–°é¢‘ç‡æ˜¯å¤šå°‘ï¼Ÿ

A: æ•´åˆ†ä»·æ ¼æ¯åˆ†é’Ÿæ›´æ–°ä¸€æ¬¡ï¼Œåœ¨æ¯ä¸ªæ•´åˆ†é’Ÿæ—¶åˆ»ï¼ˆå¦‚ 07:10:00ã€07:11:00ï¼‰æ¨é€æ–°çš„ä»·æ ¼æ•°æ®ã€‚ä»·æ ¼æ¨é€æœåŠ¡ä¼šåœ¨æ•´åˆ†é’Ÿå¼€å§‹æ—¶ç«‹å³è·å–æœ€æ–°ä»·æ ¼å¹¶æ¨é€åˆ°é“¾ä¸Šã€‚

### Q3: å¦‚ä½•åœ¨é¢„æµ‹å¸‚åœºä¸­ä½¿ç”¨æ•´åˆ†ä»·æ ¼ï¼Ÿ

A: é¢„æµ‹å¸‚åœºåº”è¯¥ä½¿ç”¨ç‰¹å®šåˆ†é’Ÿçš„ä»·æ ¼ä½œä¸ºç»“ç®—åŸºå‡†ï¼š

```solidity
function settlePrediction(uint256 predictionId) external {
    Prediction storage prediction = predictions[predictionId];
    IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
    
    // ç¡®ä¿ä»·æ ¼æ—¶é—´æˆ³å®Œå…¨åŒ¹é…ç»“ç®—æ—¶é—´
    require(priceData.publishTime == prediction.settlementTime, "Price timestamp mismatch");
    require(priceData.publishTime % 60 == 0, "Not minute-aligned price");
    
    // ä½¿ç”¨è¯¥ä»·æ ¼è¿›è¡Œç»“ç®—
    uint256 settlementPrice = uint256(uint64(priceData.price));
    // ... ç»“ç®—é€»è¾‘
}
```

### Q4: å¦‚ä½•å¤„ç†ä»·æ ¼å»¶è¿Ÿæˆ–ç¼ºå¤±ï¼Ÿ

A: å®ç°å®¹é”™æœºåˆ¶å’Œæ—¶é—´çª—å£éªŒè¯ï¼š

```solidity
function getPriceWithFallback(uint256 targetMinute) external view returns (
    uint256 price, 
    bool found
) {
    IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
    
    // é¦–å…ˆæ£€æŸ¥ç²¾ç¡®åŒ¹é…
    if (priceData.publishTime == targetMinute) {
        return (uint256(uint64(priceData.price)), true);
    }
    
    // æ£€æŸ¥æ˜¯å¦åœ¨åˆç†çš„æ—¶é—´çª—å£å†…ï¼ˆä¾‹å¦‚1åˆ†é’Ÿå®¹å·®ï¼‰
    uint256 timeDiff = priceData.publishTime > targetMinute ? 
        priceData.publishTime - targetMinute : 
        targetMinute - priceData.publishTime;
        
    if (timeDiff <= 60 && priceData.publishTime % 60 == 0) {
        return (uint256(uint64(priceData.price)), true);
    }
    
    return (0, false);
}
```

### Q5: æ•´åˆ†ä»·æ ¼æœºåˆ¶å¯¹Gasæ¶ˆè€—æœ‰ä»€ä¹ˆå½±å“ï¼Ÿ

A: æ•´åˆ†ä»·æ ¼æœºåˆ¶å®é™…ä¸Šæœ‰åŠ©äºä¼˜åŒ–Gasæ¶ˆè€—ï¼š
- **å‡å°‘æŸ¥è¯¢é¢‘ç‡**: åº”ç”¨åªéœ€åœ¨æ•´åˆ†é’Ÿæ—¶åˆ»æŸ¥è¯¢ä»·æ ¼
- **ç¼“å­˜å‹å¥½**: åŒä¸€åˆ†é’Ÿå†…çš„å¤šæ¬¡æŸ¥è¯¢å¯ä»¥å¤ç”¨ç»“æœ
- **é¢„æµ‹æ€§**: å¯ä»¥é¢„å…ˆè®¡ç®—ä¸‹æ¬¡ä»·æ ¼æ›´æ–°æ—¶é—´

```solidity
function ensureMinutePrice(bytes32 feedId) external view returns (uint256) {
    IPyth.Price memory priceData = pyth.getPrice(feedId);
    require(priceData.publishTime % 60 == 0, "Not a minute-aligned price");
    return uint256(uint64(priceData.price));
}
```

### Q6: å¦‚ä½•åœ¨åˆçº¦ä¸­å®ç°æ•´åˆ†ä»·æ ¼ç¼“å­˜ï¼Ÿ

A: å®ç°æ™ºèƒ½ç¼“å­˜æœºåˆ¶ä»¥å‡å°‘é‡å¤æŸ¥è¯¢ï¼š

```solidity
contract PriceCache {
    struct CachedPrice {
        uint256 price;
        uint256 timestamp;
        bool valid;
    }
    
    mapping(bytes32 => mapping(uint256 => CachedPrice)) public priceCache;
    
    function getCachedMinutePrice(bytes32 feedId, uint256 minute) external returns (uint256) {
        require(minute % 60 == 0, "Not minute-aligned timestamp");
        
        CachedPrice storage cached = priceCache[feedId][minute];
        
        if (cached.valid) {
            return cached.price;
        }
        
        // ä»Oracleè·å–ä»·æ ¼
        IPyth.Price memory priceData = pyth.getPrice(feedId);
        require(priceData.publishTime == minute, "Price not available for this minute");
        
        // ç¼“å­˜ä»·æ ¼
        cached.price = uint256(uint64(priceData.price));
        cached.timestamp = priceData.publishTime;
        cached.valid = true;
        
        return cached.price;
    }
}
```

### Q7: å¦‚ä½•åœ¨DeFiåè®®ä¸­ä½¿ç”¨æ•´åˆ†ä»·æ ¼ï¼Ÿ

A: DeFiåè®®å¯ä»¥åˆ©ç”¨æ•´åˆ†ä»·æ ¼çš„ä¸€è‡´æ€§ç‰¹ç‚¹ï¼š

```solidity
contract LiquidationEngine {
    uint256 public constant LIQUIDATION_THRESHOLD = 150; // 150%
    
    function checkLiquidation(address user) external view returns (bool canLiquidate) {
        // è·å–å½“å‰æ•´åˆ†é’Ÿä»·æ ¼
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        require(priceData.publishTime % 60 == 0, "Waiting for minute-aligned price");
        
        uint256 collateralValue = getUserCollateral(user) * uint256(uint64(priceData.price));
        uint256 debtValue = getUserDebt(user) * 1e18;
        
        return (collateralValue * 100) < (debtValue * LIQUIDATION_THRESHOLD);
    }
}
```

### Q8: å¦‚ä½•å¤„ç†ä»·æ ¼å»¶è¿Ÿï¼Ÿ

A: ä½¿ç”¨ `getPriceNoOlderThan` å‡½æ•°è®¾ç½®æœ€å¤§å»¶è¿Ÿæ—¶é—´ï¼Œå¹¶ç»“åˆæ•´åˆ†ä»·æ ¼éªŒè¯ï¼š

```solidity
function getSafeMinutePrice(bytes32 feedId, uint256 maxAge) external view returns (
    uint256 price,
    uint256 timestamp
) {
    IPyth.Price memory priceData = pyth.getPriceNoOlderThan(feedId, maxAge);
    
    // ç¡®ä¿æ˜¯æ•´åˆ†ä»·æ ¼
    require(priceData.publishTime % 60 == 0, "Not minute-aligned price");
    
    return (uint256(uint64(priceData.price)), priceData.publishTime);
}
```

### Q9: å¦‚ä½•ä¼˜åŒ–Gasæ¶ˆè€—ï¼Ÿ

A: é’ˆå¯¹æ•´åˆ†ä»·æ ¼çš„Gasä¼˜åŒ–ç­–ç•¥ï¼š

1. **æ‰¹é‡æŸ¥è¯¢å¤šä¸ªæ•´åˆ†ä»·æ ¼**
```solidity
function getBatchMinutePrices(bytes32[] calldata feedIds) external view returns (
    uint256[] memory prices,
    uint256 timestamp
) {
    prices = new uint256[](feedIds.length);
    uint256 commonTimestamp;
    
    for (uint256 i = 0; i < feedIds.length; i++) {
        IPyth.Price memory priceData = pyth.getPrice(feedIds[i]);
        require(priceData.publishTime % 60 == 0, "Not minute-aligned");
        
        if (i == 0) {
            commonTimestamp = priceData.publishTime;
        } else {
            require(priceData.publishTime == commonTimestamp, "Timestamp mismatch");
        }
        
        prices[i] = uint256(uint64(priceData.price));
    }
    
    return (prices, commonTimestamp);
}
```

2. **ä½¿ç”¨äº‹ä»¶ç›‘å¬æ•´åˆ†ä»·æ ¼æ›´æ–°**
3. **å®ç°åˆ†é’Ÿçº§åˆ«çš„ä»·æ ¼ç¼“å­˜**

## æ•´åˆ†ä»·æ ¼è·å– - æ ¸å¿ƒè¦ç‚¹æ€»ç»“

### ğŸ¯ æ•´åˆ†ä»·æ ¼æœºåˆ¶çš„æ ¸å¿ƒä»·å€¼

1. **æ—¶é—´ç²¾ç¡®æ€§**: ä»·æ ¼æ—¶é—´æˆ³ä¸¥æ ¼å¯¹é½åˆ°æ•´åˆ†é’Ÿï¼ˆ`publishTime % 60 == 0`ï¼‰
2. **ä¸€è‡´æ€§ä¿è¯**: åŒä¸€åˆ†é’Ÿå†…æ‰€æœ‰æŸ¥è¯¢è¿”å›ç›¸åŒçš„ä»·æ ¼æ•°æ®
3. **é¢„æµ‹æ€§**: å¯é¢„å…ˆè®¡ç®—ä¸‹æ¬¡ä»·æ ¼æ›´æ–°æ—¶é—´ï¼Œä¾¿äºåº”ç”¨è§„åˆ’
4. **å…¬å¹³æ€§**: ä¸ºé¢„æµ‹å¸‚åœºã€æœŸæƒç­‰åº”ç”¨æä¾›å…¬å¹³çš„ç»“ç®—åŸºå‡†

### ğŸ”§ å…³é”®å®ç°æ¨¡å¼

#### åŸºç¡€éªŒè¯æ¨¡å¼
```solidity
modifier onlyMinutePrice(bytes32 feedId) {
    IPyth.Price memory price = pyth.getPrice(feedId);
    require(price.publishTime % 60 == 0, "Not minute-aligned price");
    _;
}
```

#### å®‰å…¨è·å–æ¨¡å¼
```solidity
function getSafeMinutePrice(bytes32 feedId) external view returns (uint256, uint256) {
    IPyth.Price memory price = pyth.getPrice(feedId);
    require(price.publishTime % 60 == 0, "Not minute-aligned");
    require(price.price > 0, "Invalid price");
    return (uint256(uint64(price.price)), price.publishTime);
}
```

#### é¢„æµ‹å¸‚åœºä¸“ç”¨æ¨¡å¼
```solidity
function getSettlementPrice(uint256 settlementTime) external view returns (uint256) {
    require(settlementTime % 60 == 0, "Settlement time must be minute-aligned");
    IPyth.Price memory price = pyth.getPrice(BTC_FEED_ID);
    require(price.publishTime == settlementTime, "Price timestamp mismatch");
    return uint256(uint64(price.price));
}
```

### ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **ç¼“å­˜æœºåˆ¶**: åŒä¸€åˆ†é’Ÿå†…å¤ç”¨ä»·æ ¼æ•°æ®
2. **æ‰¹é‡æŸ¥è¯¢**: ä¸€æ¬¡è·å–å¤šä¸ªèµ„äº§çš„æ•´åˆ†ä»·æ ¼
3. **äº‹ä»¶ç›‘å¬**: ç›‘å¬ä»·æ ¼æ›´æ–°äº‹ä»¶è€Œéè½®è¯¢
4. **æ—¶é—´çª—å£**: åˆç†è®¾ç½®ä»·æ ¼æœ‰æ•ˆæœŸå’Œå®¹é”™èŒƒå›´

### âš ï¸ é‡è¦æ³¨æ„äº‹é¡¹

- å§‹ç»ˆéªŒè¯ `publishTime % 60 == 0`
- æ£€æŸ¥ä»·æ ¼çš„æœ‰æ•ˆæ€§ï¼ˆéé›¶ã€éè´Ÿï¼‰
- è€ƒè™‘ç½‘ç»œå»¶è¿Ÿå’Œä»·æ ¼æ¨é€æ—¶é—´
- ä¸ºå…³é”®åº”ç”¨å®ç°é™çº§å’Œå®¹é”™æœºåˆ¶

## æ€»ç»“

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†å¦‚ä½•åœ¨é“¾ä¸Šåˆçº¦ä¸­è°ƒç”¨ Oracle ä»·æ ¼æ•°æ®ï¼Œ**ç‰¹åˆ«ä¸“æ³¨äºæ•´åˆ†ä»·æ ¼çš„è·å–å’Œåº”ç”¨**ã€‚é€šè¿‡æ•´åˆ†ä»·æ ¼æœºåˆ¶ï¼Œå¼€å‘è€…å¯ä»¥æ„å»ºæ›´åŠ å…¬å¹³ã€ä¸€è‡´å’Œå¯é¢„æµ‹çš„å»ä¸­å¿ƒåŒ–åº”ç”¨ï¼Œç‰¹åˆ«é€‚ç”¨äºé¢„æµ‹å¸‚åœºã€æœŸæƒäº¤æ˜“ã€DeFi åè®®ç­‰å¯¹ä»·æ ¼æ—¶é—´ç²¾ç¡®æ€§æœ‰ä¸¥æ ¼è¦æ±‚çš„åœºæ™¯ã€‚

æ•´åˆ†ä»·æ ¼æœºåˆ¶ä¸ä»…æä¾›äº†æŠ€æœ¯ä¸Šçš„ä¼˜åŠ¿ï¼Œæ›´ä¸ºåŒºå—é“¾åº”ç”¨å¸¦æ¥äº†ä¸šåŠ¡å±‚é¢çš„åˆ›æ–°å¯èƒ½æ€§ï¼Œæ˜¯æ„å»ºä¸‹ä¸€ä»£ DeFi åŸºç¡€è®¾æ–½çš„é‡è¦å·¥å…·ã€‚