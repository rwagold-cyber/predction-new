# Pyth Oracle 链上合约调用 API 文档

## 概述

本文档专门介绍如何在 Solidity 智能合约中调用 Pyth Oracle 的**整分价格数据**。整分价格机制是本Oracle系统的核心特性，为智能合约提供精确的时间基准和一致性保证。

## 🕐 整分价格机制 - 链上调用的核心

### 什么是整分价格？

整分价格是指在每个整分钟时刻（如 07:10:00、07:11:00）推送的价格数据，其 `publishTime` 时间戳的秒数和毫秒数均为0，确保：

- **时间精确性**: 所有价格都在整分钟时刻发布
- **一致性保证**: 同一分钟内所有合约调用获得相同价格
- **可预测性**: 开发者可以准确预期价格更新时间
- **公平性**: 为预测市场和期权合约提供公平的结算基准

### 🚀 整分价格在链上的核心优势

**链上整分价格调用的核心价值**：

- **预测市场结算**: 提供精确的时间基准用于预测结果确定
- **期权合约到期**: 在特定分钟时刻获取准确的结算价格
- **DeFi协议触发**: 基于整分钟价格的自动化协议执行
- **价格竞猜游戏**: 公平透明的价格参考点
- **时间一致性**: 确保所有合约调用获得相同时间点的价格

## 合约信息

- **Oracle合约地址**: `0x132923f95FD7E8a6FD8aC302D8fd92317F23aFfd`
- **网络**: Socrates Testnet
- **RPC**: https://rpc-testnet.socrateschain.org
- **Chain ID**: 1111111
- **接口**: `IPyth.sol`

## 接口定义

### IPyth 接口

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

interface IPyth {
    struct Price {
        int64 price;          // 价格（带指数小数位）
        uint64 conf;          // 置信区间
        int32 expo;           // 指数（小数位数，通常为-8）
        uint publishTime;     // 发布时间戳（Unix时间，整分钟）
    }

    struct PriceFeed {
        bytes32 id;           // 价格feed标识符
        Price price;          // 当前价格
        Price emaPrice;       // 指数移动平均价格
    }

    // ==================== 基础价格查询函数 ====================

    /// @notice 获取指定feed的当前价格（整分价格）
    /// @param id 价格feed标识符
    /// @return price 价格结构体，publishTime为整分钟时刻
    function getPrice(bytes32 id) external view returns (Price memory price);

    /// @notice 获取完整的价格feed信息
    /// @param id 价格feed标识符
    /// @return priceFeed 包含当前价格和EMA价格的完整信息
    function getPriceFeed(bytes32 id) external view returns (PriceFeed memory priceFeed);

    /// @notice 获取不超过指定时效的价格
    /// @param id 价格feed标识符
    /// @param age 最大允许的价格年龄（秒）
    /// @return price 价格结构体
    function getPriceNoOlderThan(bytes32 id, uint age) external view returns (Price memory price);

    /// @notice 获取EMA价格
    /// @param id 价格feed标识符
    /// @return price EMA价格结构体
    function getEmaPrice(bytes32 id) external view returns (Price memory price);

    /// @notice 检查价格feed是否存在
    /// @param id 价格feed标识符
    /// @return exists 是否存在
    function priceFeedExists(bytes32 id) external view returns (bool exists);

    /// @notice 获取价格（不检查时效性，可能过时）
    /// @param id 价格feed标识符
    /// @return price 价格结构体
    function getPriceUnsafe(bytes32 id) external view returns (Price memory price);

    // ==================== V2 新增：历史整分价格查询函数 ====================

    /// @notice 获取指定整分钟时间戳的历史价格 ⭐ 核心函数
    /// @dev 这是获取历史整分价格的主要函数，适用于预测市场结算等场景
    /// @param id 价格feed标识符
    /// @param timestamp 整分钟时间戳（必须是60的倍数）
    /// @return price 指定时间的价格数据
    function getPriceAtZeroTimestamp(
        bytes32 id, 
        uint256 timestamp
    ) external view returns (Price memory price);

    /// @notice 获取最近的整分钟价格
    /// @param id 价格feed标识符
    /// @return price 最近记录的整分钟价格
    function getLastZeroPrice(bytes32 id) external view returns (Price memory price);

    /// @notice 获取所有整分钟时间戳列表
    /// @param id 价格feed标识符
    /// @return timestamps 所有已记录的整分钟时间戳数组
    function getZeroTimestamps(bytes32 id) external view returns (uint256[] memory timestamps);

    /// @notice 分页获取整分钟时间戳
    /// @param id 价格feed标识符
    /// @param offset 起始偏移量
    /// @param limit 返回数量限制
    /// @return timestamps 时间戳数组
    function getZeroTimestampsPaginated(
        bytes32 id,
        uint256 offset,
        uint256 limit
    ) external view returns (uint256[] memory timestamps);

    /// @notice 批量获取多个时间戳的价格
    /// @param id 价格feed标识符
    /// @param timestamps 时间戳数组
    /// @return prices 对应的价格数组
    function getBatchPricesAtZero(
        bytes32 id,
        uint256[] calldata timestamps
    ) external view returns (Price[] memory prices);

    /// @notice 检查是否可以在指定时间戳设置价格
    /// @param id 价格feed标识符
    /// @param timestamp 时间戳
    /// @return canSet 是否可以设置
    /// @return reason 不能设置的原因
    function canSetPriceAtZero(
        bytes32 id,
        uint256 timestamp
    ) external view returns (bool canSet, string memory reason);
}
```

## 价格Feed常量

```solidity
// 价格Feed ID常量定义
library PythFeeds {
    /// @notice BTC/USD 价格feed ID
    /// @dev 通过 keccak256("BTCUSD") 生成
    bytes32 public constant BTC_USD = 0x7404e3d104ea7841c3d9e6fd20adfe99b4ad586bc08d8f3bd3afef894cf184de;
    
    /// @notice 价格精度常量（8位小数）
    int32 public constant PRICE_EXPO = -8;
    uint256 public constant PRICE_PRECISION = 1e8;
}
```

## 基础合约示例

### 1. 简单价格查询合约

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./IPyth.sol";

contract SimplePriceConsumer {
    IPyth public immutable pyth;
    bytes32 public constant BTC_FEED_ID = 0x7404e3d104ea7841c3d9e6fd20adfe99b4ad586bc08d8f3bd3afef894cf184de;
    
    constructor(address _pyth) {
        pyth = IPyth(_pyth);
    }
    
    /// @notice 获取BTC当前价格（整分价格）
    /// @return price 价格（USD，8位小数）
    /// @return timestamp 价格时间戳（整分钟）
    function getBTCPrice() external view returns (uint256 price, uint256 timestamp) {
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        require(priceData.price > 0, "Invalid price");
        require(priceData.expo == -8, "Unexpected price exponent");
        
        // 验证整分钟时间戳
        require(priceData.publishTime % 60 == 0, "Price timestamp not minute-aligned");
        
        return (
            uint256(uint64(priceData.price)),
            priceData.publishTime
        );
    }
    
    /// @notice 获取BTC价格（USD格式，去除小数位）
    /// @return priceInUSD 价格（USD，整数部分）
    function getBTCPriceInUSD() external view returns (uint256 priceInUSD) {
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        require(priceData.price > 0, "Invalid price");
        require(priceData.expo == -8, "Unexpected price exponent");
        
        // 转换为USD（除以10^8）
        return uint256(uint64(priceData.price)) / 1e8;
    }
    
    /// @notice 检查价格是否为指定分钟的价格
    /// @param targetMinute 目标分钟时间戳（必须为整分钟）
    /// @return isMatch 是否匹配
    function isPriceForMinute(uint256 targetMinute) external view returns (bool isMatch) {
        require(targetMinute % 60 == 0, "Target minute must be minute-aligned");
        
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        return priceData.publishTime == targetMinute;
    }
    
    /// @notice 验证并获取整分价格（带完整验证）
    /// @return price 价格（USD，8位小数）
    /// @return timestamp 整分钟时间戳
    /// @return isValid 价格是否有效
    function getValidatedMinutePrice() external view returns (
        uint256 price, 
        uint256 timestamp, 
        bool isValid
    ) {
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        // 验证价格基本有效性
        if (priceData.price <= 0 || priceData.expo != -8) {
            return (0, 0, false);
        }
        
        // 核心验证：确保是整分钟价格
        if (priceData.publishTime % 60 != 0) {
            return (0, 0, false);
        }
        
        // 验证价格不超过5分钟
        if (block.timestamp - priceData.publishTime > 300) {
            return (0, 0, false);
        }
        
        return (
            uint256(uint64(priceData.price)),
            priceData.publishTime,
            true
        );
    }
    
    /// @notice 获取当前分钟的价格（如果可用）
    /// @return price 当前分钟价格
    /// @return available 是否可用
    function getCurrentMinutePrice() external view returns (uint256 price, bool available) {
        // 计算当前整分钟时间戳
        uint256 currentMinute = (block.timestamp / 60) * 60;
        
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        if (priceData.publishTime == currentMinute && priceData.price > 0) {
            return (uint256(uint64(priceData.price)), true);
        }
        
        return (0, false);
    }
    
    /// @notice 等待并获取下一个整分钟价格（视图函数，用于预测）
    /// @return nextMinuteTimestamp 下一个整分钟时间戳
    /// @return secondsToWait 需要等待的秒数
    function getNextMinuteInfo() external view returns (uint256 nextMinuteTimestamp, uint256 secondsToWait) {
        uint256 currentMinute = (block.timestamp / 60) * 60;
        nextMinuteTimestamp = currentMinute + 60;
        secondsToWait = nextMinuteTimestamp - block.timestamp;
    }
    
    // ==================== V2 新增：历史价格查询示例 ====================
    
    /// @notice 获取指定时间的历史价格 ⭐ 核心功能
    /// @param targetTimestamp 目标整分钟时间戳
    /// @return price 历史价格
    /// @return isValid 是否找到有效价格
    function getHistoricalPrice(uint256 targetTimestamp) external view returns (
        uint256 price, 
        bool isValid
    ) {
        require(targetTimestamp % 60 == 0, "Timestamp must be minute-aligned");
        
        try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, targetTimestamp) returns (IPyth.Price memory priceData) {
            require(priceData.price > 0, "Invalid historical price");
            return (uint256(uint64(priceData.price)), true);
        } catch {
            return (0, false);
        }
    }
    
    /// @notice 获取最近N分钟的价格历史
    /// @param minutesBack 回溯分钟数
    /// @return prices 价格数组
    /// @return timestamps 对应的时间戳数组
    function getRecentPriceHistory(uint256 minutesBack) external view returns (
        uint256[] memory prices,
        uint256[] memory timestamps
    ) {
        require(minutesBack > 0 && minutesBack <= 60, "Invalid minutes range");
        
        uint256 currentMinute = (block.timestamp / 60) * 60;
        prices = new uint256[](minutesBack);
        timestamps = new uint256[](minutesBack);
        
        for (uint256 i = 0; i < minutesBack; i++) {
            uint256 targetTime = currentMinute - (i * 60);
            timestamps[minutesBack - 1 - i] = targetTime;
            
            try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, targetTime) returns (IPyth.Price memory priceData) {
                if (priceData.price > 0) {
                    prices[minutesBack - 1 - i] = uint256(uint64(priceData.price));
                }
            } catch {
                prices[minutesBack - 1 - i] = 0; // 标记为无效价格
            }
        }
    }
    
    /// @notice 检查指定时间是否有价格数据
    /// @param targetTimestamp 目标时间戳
    /// @return hasPrice 是否有价格数据
    /// @return priceAge 价格年龄（秒）
    function checkPriceAvailability(uint256 targetTimestamp) external view returns (
        bool hasPrice, 
        uint256 priceAge
    ) {
        require(targetTimestamp % 60 == 0, "Timestamp must be minute-aligned");
        
        try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, targetTimestamp) returns (IPyth.Price memory priceData) {
            if (priceData.publishTime == targetTimestamp && priceData.price > 0) {
                priceAge = block.timestamp - targetTimestamp;
                return (true, priceAge);
            }
        } catch {
            // 价格不存在
        }
        
        return (false, 0);
    }
}
```

### 2. 预测市场结算合约

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./IPyth.sol";

contract PredictionMarketSettlement {
    IPyth public immutable pyth;
    bytes32 public constant BTC_FEED_ID = 0x7404e3d104ea7841c3d9e6fd20adfe99b4ad586bc08d8f3bd3afef894cf184de;
    
    struct Prediction {
        uint256 settlementTime;    // 结算时间（整分钟）
        uint256 targetPrice;       // 预测价格
        address predictor;         // 预测者
        bool settled;              // 是否已结算
        bool won;                  // 是否获胜
        uint256 actualPrice;       // 实际结算价格
    }
    
    mapping(uint256 => Prediction) public predictions;
    uint256 public nextPredictionId;
    
    event PredictionCreated(uint256 indexed predictionId, address indexed predictor, uint256 settlementTime, uint256 targetPrice);
    event PredictionSettled(uint256 indexed predictionId, uint256 actualPrice, bool won);
    
    constructor(address _pyth) {
        pyth = IPyth(_pyth);
    }
    
    /// @notice 创建价格预测
    /// @param settlementTime 结算时间（必须为整分钟）
    /// @param targetPrice 预测价格（USD，8位小数）
    function createPrediction(uint256 settlementTime, uint256 targetPrice) external {
        require(settlementTime % 60 == 0, "Settlement time must be minute-aligned");
        require(settlementTime > block.timestamp, "Settlement time must be in future");
        require(targetPrice > 0, "Target price must be positive");
        
        uint256 predictionId = nextPredictionId++;
        predictions[predictionId] = Prediction({
            settlementTime: settlementTime,
            targetPrice: targetPrice,
            predictor: msg.sender,
            settled: false,
            won: false,
            actualPrice: 0
        });
        
        emit PredictionCreated(predictionId, msg.sender, settlementTime, targetPrice);
    }
    
    /// @notice 结算预测（使用当前价格）
    /// @param predictionId 预测ID
    function settlePrediction(uint256 predictionId) external {
        Prediction storage prediction = predictions[predictionId];
        require(!prediction.settled, "Prediction already settled");
        require(block.timestamp >= prediction.settlementTime + 60, "Settlement time not reached");
        
        // 获取结算时间的价格
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        // 验证价格时间戳是否匹配结算时间
        require(priceData.publishTime == prediction.settlementTime, "Price timestamp mismatch");
        
        uint256 actualPrice = uint256(uint64(priceData.price));
        
        // 判断预测是否正确（允许1%误差）
        uint256 tolerance = actualPrice / 100; // 1%容差
        bool won = actualPrice >= prediction.targetPrice - tolerance && 
                   actualPrice <= prediction.targetPrice + tolerance;
        
        prediction.settled = true;
        prediction.won = won;
        prediction.actualPrice = actualPrice;
        
        emit PredictionSettled(predictionId, actualPrice, won);
    }
    
    // ==================== V2 新增：历史价格结算功能 ====================
    
    /// @notice 使用历史价格结算预测 ⭐ 核心功能
    /// @dev 这是预测市场的核心功能，使用精确的历史整分价格进行结算
    /// @param predictionId 预测ID
    function settleWithHistoricalPrice(uint256 predictionId) external {
        Prediction storage prediction = predictions[predictionId];
        require(!prediction.settled, "Prediction already settled");
        require(block.timestamp >= prediction.settlementTime + 60, "Wait for price confirmation");
        
        // 使用 getPriceAtZeroTimestamp 获取精确的历史价格
        IPyth.Price memory historicalPrice = pyth.getPriceAtZeroTimestamp(
            BTC_FEED_ID, 
            prediction.settlementTime
        );
        
        // 验证历史价格的有效性
        require(historicalPrice.publishTime == prediction.settlementTime, "Historical price timestamp mismatch");
        require(historicalPrice.price > 0, "Invalid historical price");
        
        uint256 actualPrice = uint256(uint64(historicalPrice.price));
        
        // 判断预测结果（允许1%误差）
        uint256 tolerance = actualPrice / 100;
        bool won = actualPrice >= prediction.targetPrice - tolerance && 
                   actualPrice <= prediction.targetPrice + tolerance;
        
        prediction.settled = true;
        prediction.won = won;
        prediction.actualPrice = actualPrice;
        
        emit PredictionSettled(predictionId, actualPrice, won);
    }
    
    /// @notice 批量结算多个预测
    /// @param predictionIds 预测ID数组
    function batchSettleWithHistoricalPrice(uint256[] calldata predictionIds) external {
        for (uint256 i = 0; i < predictionIds.length; i++) {
            uint256 predictionId = predictionIds[i];
            Prediction storage prediction = predictions[predictionId];
            
            // 跳过已结算或时间未到的预测
            if (prediction.settled || block.timestamp < prediction.settlementTime + 60) {
                continue;
            }
            
            try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, prediction.settlementTime) returns (IPyth.Price memory historicalPrice) {
                if (historicalPrice.publishTime == prediction.settlementTime && historicalPrice.price > 0) {
                    uint256 actualPrice = uint256(uint64(historicalPrice.price));
                    uint256 tolerance = actualPrice / 100;
                    bool won = actualPrice >= prediction.targetPrice - tolerance && 
                               actualPrice <= prediction.targetPrice + tolerance;
                    
                    prediction.settled = true;
                    prediction.won = won;
                    prediction.actualPrice = actualPrice;
                    
                    emit PredictionSettled(predictionId, actualPrice, won);
                }
            } catch {
                // 历史价格不可用，跳过此预测
                continue;
            }
        }
    }
    
    /// @notice 检查预测是否可以结算
    /// @param predictionId 预测ID
    /// @return canSettle 是否可以结算
    /// @return reason 不能结算的原因
    function canSettlePrediction(uint256 predictionId) external view returns (
        bool canSettle, 
        string memory reason
    ) {
        Prediction storage prediction = predictions[predictionId];
        
        if (prediction.settled) {
            return (false, "Already settled");
        }
        
        if (block.timestamp < prediction.settlementTime + 60) {
            return (false, "Settlement time not reached");
        }
        
        // 检查历史价格是否可用
        try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, prediction.settlementTime) returns (IPyth.Price memory historicalPrice) {
            if (historicalPrice.publishTime == prediction.settlementTime && historicalPrice.price > 0) {
                return (true, "Ready to settle");
            } else {
                return (false, "Historical price not available or invalid");
            }
        } catch {
            return (false, "Historical price not found");
        }
    }
    
    /// @notice 获取预测的历史价格（用于预览）
    /// @param predictionId 预测ID
    /// @return price 历史价格
    /// @return available 价格是否可用
    function getHistoricalPriceForPrediction(uint256 predictionId) external view returns (
        uint256 price, 
        bool available
    ) {
        Prediction storage prediction = predictions[predictionId];
        
        try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, prediction.settlementTime) returns (IPyth.Price memory historicalPrice) {
            if (historicalPrice.publishTime == prediction.settlementTime && historicalPrice.price > 0) {
                return (uint256(uint64(historicalPrice.price)), true);
            }
        } catch {
            // 价格不可用
        }
        
        return (0, false);
    }
    
    /// @notice 获取指定时间的价格（用于验证）
    /// @param targetTime 目标时间（整分钟）
    /// @return price 价格
    /// @return isAvailable 价格是否可用
    function getPriceAtTime(uint256 targetTime) external view returns (uint256 price, bool isAvailable) {
        require(targetTime % 60 == 0, "Target time must be minute-aligned");
        
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        if (priceData.publishTime == targetTime) {
            return (uint256(uint64(priceData.price)), true);
        } else {
            return (0, false);
        }
    }
}
```

### 3. 期权合约示例

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./IPyth.sol";

contract BTCOption {
    IPyth public immutable pyth;
    bytes32 public constant BTC_FEED_ID = 0x7404e3d104ea7841c3d9e6fd20adfe99b4ad586bc08d8f3bd3afef894cf184de;
    
    struct Option {
        uint256 strikePrice;       // 行权价格（USD，8位小数）
        uint256 expiryTime;        // 到期时间（整分钟）
        uint256 premium;           // 期权费
        address buyer;             // 买方
        address seller;            // 卖方
        bool exercised;            // 是否已行权
        bool settled;              // 是否已结算
        OptionType optionType;     // 期权类型
    }
    
    enum OptionType { CALL, PUT }
    
    mapping(uint256 => Option) public options;
    uint256 public nextOptionId;
    
    event OptionCreated(uint256 indexed optionId, address indexed buyer, address indexed seller, uint256 strikePrice, uint256 expiryTime);
    event OptionExercised(uint256 indexed optionId, uint256 spotPrice, uint256 payout);
    
    constructor(address _pyth) {
        pyth = IPyth(_pyth);
    }
    
    /// @notice 创建期权
    /// @param strikePrice 行权价格
    /// @param expiryTime 到期时间（整分钟）
    /// @param optionType 期权类型
    function createOption(
        uint256 strikePrice,
        uint256 expiryTime,
        OptionType optionType
    ) external payable {
        require(expiryTime % 60 == 0, "Expiry time must be minute-aligned");
        require(expiryTime > block.timestamp, "Expiry time must be in future");
        require(strikePrice > 0, "Strike price must be positive");
        require(msg.value > 0, "Premium must be positive");
        
        uint256 optionId = nextOptionId++;
        options[optionId] = Option({
            strikePrice: strikePrice,
            expiryTime: expiryTime,
            premium: msg.value,
            buyer: msg.sender,
            seller: address(0), // 需要单独设置卖方
            exercised: false,
            settled: false,
            optionType: optionType
        });
        
        emit OptionCreated(optionId, msg.sender, address(0), strikePrice, expiryTime);
    }
    
    /// @notice 行权期权
    /// @param optionId 期权ID
    function exerciseOption(uint256 optionId) external {
        Option storage option = options[optionId];
        require(msg.sender == option.buyer, "Only buyer can exercise");
        require(!option.exercised, "Option already exercised");
        require(block.timestamp >= option.expiryTime, "Option not yet expired");
        require(block.timestamp < option.expiryTime + 300, "Exercise window closed"); // 5分钟行权窗口
        
        // 获取到期时间的价格
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        require(priceData.publishTime == option.expiryTime, "Price not available for expiry time");
        
        uint256 spotPrice = uint256(uint64(priceData.price));
        uint256 payout = 0;
        
        if (option.optionType == OptionType.CALL) {
            // 看涨期权：现价 > 行权价时有价值
            if (spotPrice > option.strikePrice) {
                payout = spotPrice - option.strikePrice;
            }
        } else {
            // 看跌期权：现价 < 行权价时有价值
            if (spotPrice < option.strikePrice) {
                payout = option.strikePrice - spotPrice;
            }
        }
        
        option.exercised = true;
        option.settled = true;
        
        if (payout > 0) {
            // 实际实现中需要考虑资金池和结算机制
            payable(option.buyer).transfer(payout);
        }
        
        emit OptionExercised(optionId, spotPrice, payout);
    }
    
    /// @notice 检查期权是否可以行权
    /// @param optionId 期权ID
    /// @return canExercise 是否可以行权
    /// @return spotPrice 当前价格
    /// @return intrinsicValue 内在价值
    function checkExercisability(uint256 optionId) external view returns (
        bool canExercise,
        uint256 spotPrice,
        uint256 intrinsicValue
    ) {
        Option storage option = options[optionId];
        
        if (option.exercised || block.timestamp < option.expiryTime) {
            return (false, 0, 0);
        }
        
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        if (priceData.publishTime != option.expiryTime) {
            return (false, 0, 0);
        }
        
        spotPrice = uint256(uint64(priceData.price));
        
        if (option.optionType == OptionType.CALL) {
            intrinsicValue = spotPrice > option.strikePrice ? spotPrice - option.strikePrice : 0;
        } else {
            intrinsicValue = spotPrice < option.strikePrice ? option.strikePrice - spotPrice : 0;
        }
        
        canExercise = intrinsicValue > 0;
    }
}
```

## 价格处理工具库

### PriceUtils 库

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./IPyth.sol";

library PriceUtils {
    /// @notice 将Pyth价格转换为USD格式
    /// @param priceData Pyth价格数据
    /// @return priceInUSD USD价格（去除小数位）
    function toUSD(IPyth.Price memory priceData) internal pure returns (uint256 priceInUSD) {
        require(priceData.price > 0, "Invalid price");
        require(priceData.expo == -8, "Unexpected price exponent");
        
        return uint256(uint64(priceData.price)) / 1e8;
    }
    
    /// @notice 将Pyth价格转换为带小数的USD格式
    /// @param priceData Pyth价格数据
    /// @return priceWithDecimals 带8位小数的价格
    function toUSDWithDecimals(IPyth.Price memory priceData) internal pure returns (uint256 priceWithDecimals) {
        require(priceData.price > 0, "Invalid price");
        require(priceData.expo == -8, "Unexpected price exponent");
        
        return uint256(uint64(priceData.price));
    }
    
    /// @notice 验证价格时间戳是否为整分钟（核心函数）
    /// @param priceData Pyth价格数据
    /// @return isMinuteAligned 是否为整分钟对齐
    function isMinuteAligned(IPyth.Price memory priceData) internal pure returns (bool isMinuteAligned) {
        return priceData.publishTime % 60 == 0;
    }
    
    /// @notice 验证是否为有效的整分价格（完整验证）
    /// @param priceData Pyth价格数据
    /// @return isValid 是否为有效的整分价格
    function isValidMinutePrice(IPyth.Price memory priceData) internal pure returns (bool isValid) {
        return priceData.price > 0 && 
               priceData.expo == -8 && 
               priceData.publishTime % 60 == 0;
    }
    
    /// @notice 获取指定时间戳的整分钟时间戳
    /// @param timestamp 任意时间戳
    /// @return minuteTimestamp 对应的整分钟时间戳
    function toMinuteTimestamp(uint256 timestamp) internal pure returns (uint256 minuteTimestamp) {
        return (timestamp / 60) * 60;
    }
    
    /// @notice 检查价格是否为指定分钟的价格
    /// @param priceData Pyth价格数据
    /// @param targetMinute 目标分钟时间戳
    /// @return isMatch 是否匹配
    function isPriceForMinute(IPyth.Price memory priceData, uint256 targetMinute) internal pure returns (bool isMatch) {
        require(targetMinute % 60 == 0, "Target minute must be minute-aligned");
        return priceData.publishTime == targetMinute;
    }
    
    /// @notice 验证整分价格的时效性
    /// @param priceData Pyth价格数据
    /// @param maxAgeMinutes 最大允许年龄（分钟）
    /// @return isRecent 是否在时效范围内
    function isRecentMinutePrice(IPyth.Price memory priceData, uint256 maxAgeMinutes) internal view returns (bool isRecent) {
        require(priceData.publishTime % 60 == 0, "Price not minute-aligned");
        return (block.timestamp - priceData.publishTime) <= (maxAgeMinutes * 60);
    }
    
    /// @notice 检查价格是否不超过指定年龄
    /// @param priceData Pyth价格数据
    /// @param maxAge 最大年龄（秒）
    /// @return isRecent 是否为最近价格
    function isRecent(IPyth.Price memory priceData, uint256 maxAge) internal view returns (bool isRecent) {
        return (block.timestamp - priceData.publishTime) <= maxAge;
    }
    
    /// @notice 计算价格变化百分比
    /// @param oldPrice 旧价格
    /// @param newPrice 新价格
    /// @return changePercent 变化百分比（基点，10000 = 100%）
    function calculatePriceChange(uint256 oldPrice, uint256 newPrice) internal pure returns (int256 changePercent) {
        require(oldPrice > 0, "Old price must be positive");
        
        if (newPrice >= oldPrice) {
            return int256(((newPrice - oldPrice) * 10000) / oldPrice);
        } else {
            return -int256(((oldPrice - newPrice) * 10000) / oldPrice);
        }
    }
    
    /// @notice 检查价格是否在指定范围内
    /// @param price 价格
    /// @param target 目标价格
    /// @param tolerancePercent 容差百分比（基点，100 = 1%）
    /// @return inRange 是否在范围内
    function isPriceInRange(uint256 price, uint256 target, uint256 tolerancePercent) internal pure returns (bool inRange) {
        uint256 tolerance = (target * tolerancePercent) / 10000;
        return price >= target - tolerance && price <= target + tolerance;
    }
}
```

## 安全考虑

### 1. 价格验证

```solidity
contract SecurePriceConsumer {
    IPyth public immutable pyth;
    bytes32 public constant BTC_FEED_ID = 0x7404e3d104ea7841c3d9e6fd20adfe99b4ad586bc08d8f3bd3afef894cf184de;
    
    uint256 public constant MAX_PRICE_AGE = 300; // 5分钟
    uint256 public constant MIN_PRICE = 1000 * 1e8; // $1,000
    uint256 public constant MAX_PRICE = 1000000 * 1e8; // $1,000,000
    
    modifier validPrice(IPyth.Price memory priceData) {
        require(priceData.price > 0, "Price must be positive");
        require(priceData.expo == -8, "Invalid price exponent");
        require(priceData.publishTime % 60 == 0, "Price not minute-aligned");
        require(block.timestamp - priceData.publishTime <= MAX_PRICE_AGE, "Price too old");
        require(uint256(uint64(priceData.price)) >= MIN_PRICE, "Price too low");
        require(uint256(uint64(priceData.price)) <= MAX_PRICE, "Price too high");
        _;
    }
    
    function getValidatedPrice() external view returns (uint256 price, uint256 timestamp) {
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        // 应用价格验证
        require(priceData.price > 0, "Price must be positive");
        require(priceData.expo == -8, "Invalid price exponent");
        require(priceData.publishTime % 60 == 0, "Price not minute-aligned");
        require(block.timestamp - priceData.publishTime <= MAX_PRICE_AGE, "Price too old");
        require(uint256(uint64(priceData.price)) >= MIN_PRICE, "Price too low");
        require(uint256(uint64(priceData.price)) <= MAX_PRICE, "Price too high");
        
        return (uint256(uint64(priceData.price)), priceData.publishTime);
    }
}
```

### 2. 重入攻击防护

```solidity
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract SecureOptionContract is ReentrancyGuard {
    // 使用 nonReentrant 修饰符保护关键函数
    function exerciseOption(uint256 optionId) external nonReentrant {
        // 期权行权逻辑
    }
}
```

## Gas 优化建议

### 1. 批量价格查询

```solidity
contract BatchPriceConsumer {
    IPyth public immutable pyth;
    
    struct PriceInfo {
        uint256 price;
        uint256 timestamp;
        bool valid;
    }
    
    /// @notice 批量获取多个时间点的价格
    /// @param targetTimes 目标时间数组（整分钟）
    /// @return prices 价格信息数组
    function getBatchPrices(uint256[] calldata targetTimes) external view returns (PriceInfo[] memory prices) {
        prices = new PriceInfo[](targetTimes.length);
        IPyth.Price memory currentPrice = pyth.getPrice(BTC_FEED_ID);
        
        for (uint256 i = 0; i < targetTimes.length; i++) {
            if (currentPrice.publishTime == targetTimes[i]) {
                prices[i] = PriceInfo({
                    price: uint256(uint64(currentPrice.price)),
                    timestamp: currentPrice.publishTime,
                    valid: true
                });
            } else {
                prices[i] = PriceInfo({
                    price: 0,
                    timestamp: 0,
                    valid: false
                });
            }
        }
    }
}
```

### 2. 价格缓存

```solidity
contract CachedPriceConsumer {
    IPyth public immutable pyth;
    
    struct CachedPrice {
        uint256 price;
        uint256 timestamp;
        uint256 blockNumber;
    }
    
    mapping(bytes32 => CachedPrice) private priceCache;
    
    /// @notice 获取缓存的价格（同一区块内复用）
    function getCachedPrice(bytes32 feedId) external view returns (uint256 price, uint256 timestamp) {
        CachedPrice memory cached = priceCache[feedId];
        
        if (cached.blockNumber == block.number) {
            return (cached.price, cached.timestamp);
        }
        
        IPyth.Price memory priceData = pyth.getPrice(feedId);
        return (uint256(uint64(priceData.price)), priceData.publishTime);
    }
    
    /// @notice 更新价格缓存
    function updatePriceCache(bytes32 feedId) external {
        IPyth.Price memory priceData = pyth.getPrice(feedId);
        
        priceCache[feedId] = CachedPrice({
            price: uint256(uint64(priceData.price)),
            timestamp: priceData.publishTime,
            blockNumber: block.number
        });
    }
}
```

## V2 历史价格查询最佳实践

### 1. getPriceAtZeroTimestamp 核心使用模式

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./IPyth.sol";

contract HistoricalPriceBestPractices {
    IPyth public immutable pyth;
    bytes32 public constant BTC_FEED_ID = 0x7404e3d104ea7841c3d9e6fd20adfe99b4ad586bc08d8f3bd3afef894cf184de;
    
    /// @notice 安全获取历史价格的标准模式 ⭐ 推荐
    /// @param timestamp 整分钟时间戳
    /// @return price 价格
    /// @return success 是否成功获取
    function safeGetHistoricalPrice(uint256 timestamp) public view returns (uint256 price, bool success) {
        // 1. 验证时间戳格式
        if (timestamp % 60 != 0) {
            return (0, false);
        }
        
        // 2. 验证时间范围（不能是未来时间）
        if (timestamp > block.timestamp) {
            return (0, false);
        }
        
        // 3. 安全调用 getPriceAtZeroTimestamp
        try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, timestamp) returns (IPyth.Price memory priceData) {
            // 4. 验证返回的价格数据
            if (priceData.publishTime == timestamp && priceData.price > 0) {
                return (uint256(uint64(priceData.price)), true);
            }
        } catch {
            // 价格不存在或查询失败
        }
        
        return (0, false);
    }
    
    /// @notice 批量获取历史价格（Gas优化）
    /// @param timestamps 时间戳数组
    /// @return prices 价格数组
    /// @return successes 成功标志数组
    function batchGetHistoricalPrices(uint256[] calldata timestamps) external view returns (
        uint256[] memory prices,
        bool[] memory successes
    ) {
        prices = new uint256[](timestamps.length);
        successes = new bool[](timestamps.length);
        
        for (uint256 i = 0; i < timestamps.length; i++) {
            (prices[i], successes[i]) = safeGetHistoricalPrice(timestamps[i]);
        }
    }
    
    /// @notice 获取时间范围内的历史价格
    /// @param startTime 开始时间（整分钟）
    /// @param endTime 结束时间（整分钟）
    /// @return timestamps 时间戳数组
    /// @return prices 价格数组
    function getHistoricalPriceRange(uint256 startTime, uint256 endTime) external view returns (
        uint256[] memory timestamps,
        uint256[] memory prices
    ) {
        require(startTime % 60 == 0 && endTime % 60 == 0, "Times must be minute-aligned");
        require(startTime <= endTime, "Invalid time range");
        require(endTime <= block.timestamp, "End time cannot be in future");
        
        uint256 count = (endTime - startTime) / 60 + 1;
        require(count <= 100, "Range too large"); // 限制最大查询范围
        
        timestamps = new uint256[](count);
        prices = new uint256[](count);
        
        uint256 validCount = 0;
        for (uint256 i = 0; i < count; i++) {
            uint256 timestamp = startTime + (i * 60);
            (uint256 price, bool success) = safeGetHistoricalPrice(timestamp);
            
            if (success) {
                timestamps[validCount] = timestamp;
                prices[validCount] = price;
                validCount++;
            }
        }
        
        // 调整数组大小
        assembly {
            mstore(timestamps, validCount)
            mstore(prices, validCount)
        }
    }
}
```

### 2. 预测市场专用历史价格模式

```solidity
contract PredictionMarketHistoricalPrice {
    IPyth public immutable pyth;
    
    /// @notice 预测市场结算专用模式
    /// @param feedId 价格源ID
    /// @param settlementTime 结算时间
    /// @param gracePeriod 宽限期（秒）
    /// @return price 结算价格
    /// @return isValid 是否有效
    function getSettlementPrice(
        bytes32 feedId,
        uint256 settlementTime,
        uint256 gracePeriod
    ) external view returns (uint256 price, bool isValid) {
        // 1. 验证结算时间必须是整分钟
        require(settlementTime % 60 == 0, "Settlement time must be minute-aligned");
        
        // 2. 确保已过结算时间 + 宽限期
        require(block.timestamp >= settlementTime + gracePeriod, "Settlement not ready");
        
        // 3. 获取精确的历史价格
        try pyth.getPriceAtZeroTimestamp(feedId, settlementTime) returns (IPyth.Price memory priceData) {
            if (priceData.publishTime == settlementTime && priceData.price > 0) {
                return (uint256(uint64(priceData.price)), true);
            }
        } catch {
            // 历史价格不可用
        }
        
        return (0, false);
    }
    
    /// @notice 检查结算价格可用性
    /// @param feedId 价格源ID
    /// @param settlementTime 结算时间
    /// @return available 是否可用
    /// @return waitTime 需要等待的时间（秒）
    function checkSettlementAvailability(
        bytes32 feedId,
        uint256 settlementTime
    ) external view returns (bool available, uint256 waitTime) {
        require(settlementTime % 60 == 0, "Settlement time must be minute-aligned");
        
        if (block.timestamp < settlementTime) {
            return (false, settlementTime - block.timestamp);
        }
        
        // 检查历史价格是否已可用
        try pyth.getPriceAtZeroTimestamp(feedId, settlementTime) returns (IPyth.Price memory priceData) {
            if (priceData.publishTime == settlementTime && priceData.price > 0) {
                return (true, 0);
            }
        } catch {
            // 价格可能还未上传，建议等待
        }
        
        // 建议等待时间：结算时间后60秒
        uint256 recommendedWaitTime = settlementTime + 60;
        if (block.timestamp < recommendedWaitTime) {
            return (false, recommendedWaitTime - block.timestamp);
        }
        
        return (false, 0); // 价格可能永久不可用
    }
}
```

### 3. 历史价格缓存优化模式

```solidity
contract HistoricalPriceCache {
    IPyth public immutable pyth;
    
    struct CachedHistoricalPrice {
        uint256 price;
        bool exists;
        uint256 cachedAt;
    }
    
    // feedId => timestamp => cached price
    mapping(bytes32 => mapping(uint256 => CachedHistoricalPrice)) private historicalCache;
    
    /// @notice 带缓存的历史价格查询
    /// @param feedId 价格源ID
    /// @param timestamp 时间戳
    /// @return price 价格
    /// @return success 是否成功
    function getCachedHistoricalPrice(bytes32 feedId, uint256 timestamp) external returns (uint256 price, bool success) {
        require(timestamp % 60 == 0, "Timestamp must be minute-aligned");
        
        // 1. 检查缓存
        CachedHistoricalPrice storage cached = historicalCache[feedId][timestamp];
        if (cached.cachedAt > 0) {
            return (cached.price, cached.exists);
        }
        
        // 2. 查询历史价格
        try pyth.getPriceAtZeroTimestamp(feedId, timestamp) returns (IPyth.Price memory priceData) {
            if (priceData.publishTime == timestamp && priceData.price > 0) {
                // 缓存成功结果
                cached.price = uint256(uint64(priceData.price));
                cached.exists = true;
                cached.cachedAt = block.timestamp;
                return (cached.price, true);
            }
        } catch {
            // 查询失败
        }
        
        // 3. 缓存失败结果（避免重复查询）
        cached.exists = false;
        cached.cachedAt = block.timestamp;
        return (0, false);
    }
    
    /// @notice 预热历史价格缓存
    /// @param feedId 价格源ID
    /// @param timestamps 时间戳数组
    function warmupHistoricalCache(bytes32 feedId, uint256[] calldata timestamps) external {
        for (uint256 i = 0; i < timestamps.length; i++) {
            uint256 timestamp = timestamps[i];
            if (timestamp % 60 != 0) continue;
            
            // 跳过已缓存的价格
            if (historicalCache[feedId][timestamp].cachedAt > 0) continue;
            
            try pyth.getPriceAtZeroTimestamp(feedId, timestamp) returns (IPyth.Price memory priceData) {
                if (priceData.publishTime == timestamp && priceData.price > 0) {
                    historicalCache[feedId][timestamp] = CachedHistoricalPrice({
                        price: uint256(uint64(priceData.price)),
                        exists: true,
                        cachedAt: block.timestamp
                    });
                }
            } catch {
                historicalCache[feedId][timestamp] = CachedHistoricalPrice({
                    price: 0,
                    exists: false,
                    cachedAt: block.timestamp
                });
            }
        }
    }
}
```

## 事件和日志

### 价格相关事件定义

```solidity
contract PriceEventEmitter {
    event PriceQueried(
        bytes32 indexed feedId,
        uint256 price,
        uint256 timestamp,
        address indexed caller
    );
    
    event HistoricalPriceQueried(
        bytes32 indexed feedId,
        uint256 indexed timestamp,
        uint256 price,
        address indexed caller
    );
    
    event PriceValidationFailed(
        bytes32 indexed feedId,
        string reason,
        uint256 timestamp
    );
    
    event MinuteAlignedPriceUsed(
        bytes32 indexed feedId,
        uint256 price,
        uint256 minuteTimestamp,
        address indexed user
    );
    
    function queryPriceWithEvent(bytes32 feedId) external {
        IPyth.Price memory priceData = pyth.getPrice(feedId);
        
        emit PriceQueried(
            feedId,
            uint256(uint64(priceData.price)),
            priceData.publishTime,
            msg.sender
        );
        
        if (priceData.publishTime % 60 == 0) {
            emit MinuteAlignedPriceUsed(
                feedId,
                uint256(uint64(priceData.price)),
                priceData.publishTime,
                msg.sender
            );
        }
    }
}
```

## 测试合约

### 价格测试工具

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract PriceTestUtils {
    IPyth public immutable pyth;
    bytes32 public constant BTC_FEED_ID = 0x7404e3d104ea7841c3d9e6fd20adfe99b4ad586bc08d8f3bd3afef894cf184de;
    
    constructor(address _pyth) {
        pyth = IPyth(_pyth);
    }
    
    /// @notice 测试价格查询功能
    function testPriceQuery() external view returns (
        uint256 price,
        uint256 timestamp,
        bool isMinuteAligned,
        uint256 ageInSeconds
    ) {
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        return (
            uint256(uint64(priceData.price)),
            priceData.publishTime,
            priceData.publishTime % 60 == 0,
            block.timestamp - priceData.publishTime
        );
    }
    
    /// @notice 验证整分价格机制
    function verifyMinutePriceMechanism() external view returns (
        bool isValid,
        string memory message
    ) {
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        if (priceData.publishTime % 60 != 0) {
            return (false, "Price timestamp is not minute-aligned");
        }
        
        if (priceData.price <= 0) {
            return (false, "Invalid price value");
        }
        
        if (priceData.expo != -8) {
            return (false, "Unexpected price exponent");
        }
        
        return (true, "Minute price mechanism working correctly");
    }
}
```

## 部署脚本

### Hardhat 部署脚本

```javascript
// scripts/deploy-price-consumer.js
const { ethers } = require("hardhat");

async function main() {
    const PYTH_ORACLE_ADDRESS = "0x132923f95FD7E8a6FD8aC302D8fd92317F23aFfd";
    
    // 部署简单价格消费者合约
    const SimplePriceConsumer = await ethers.getContractFactory("SimplePriceConsumer");
    const priceConsumer = await SimplePriceConsumer.deploy(PYTH_ORACLE_ADDRESS);
    await priceConsumer.waitForDeployment();
    
    console.log("SimplePriceConsumer deployed to:", await priceConsumer.getAddress());
    
    // 测试价格查询
    try {
        const [price, timestamp] = await priceConsumer.getBTCPrice();
        console.log("BTC Price:", price.toString());
        console.log("Timestamp:", timestamp.toString());
        console.log("Date:", new Date(Number(timestamp) * 1000).toISOString());
    } catch (error) {
        console.error("Price query failed:", error.message);
    }
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });
```

## 最佳实践

### 1. 整分价格获取的最佳实践

#### 1.1 标准整分价格验证模式

```solidity
contract MinutePriceBestPractice {
    IPyth public immutable pyth;
    bytes32 public constant BTC_FEED_ID = 0x7404e3d104ea7841c3d9e6fd20adfe99b4ad586bc08d8f3bd3afef894cf184de;
    
    /// @notice 标准整分价格获取模式
    modifier onlyValidMinutePrice() {
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        require(priceData.price > 0, "Invalid price");
        require(priceData.expo == -8, "Invalid exponent");
        require(priceData.publishTime % 60 == 0, "Not minute-aligned");
        require(block.timestamp - priceData.publishTime <= 300, "Price too old");
        _;
    }
    
    /// @notice 安全的整分价格获取
    function getMinutePriceSafely() external view returns (
        uint256 price,
        uint256 timestamp,
        bool success
    ) {
        try pyth.getPrice(BTC_FEED_ID) returns (IPyth.Price memory priceData) {
            // 验证是否为有效的整分价格
            if (priceData.price > 0 && 
                priceData.expo == -8 && 
                priceData.publishTime % 60 == 0 &&
                block.timestamp - priceData.publishTime <= 300) {
                
                return (
                    uint256(uint64(priceData.price)),
                    priceData.publishTime,
                    true
                );
            }
        } catch {
            // 处理调用失败
        }
        
        return (0, 0, false);
    }
}
```

#### 1.2 预测市场专用模式

```solidity
contract PredictionMarketBestPractice {
    /// @notice 预测市场结算专用价格获取
    function getSettlementPrice(uint256 settlementTime) external view returns (
        uint256 price,
        bool available
    ) {
        require(settlementTime % 60 == 0, "Settlement time must be minute-aligned");
        require(settlementTime <= block.timestamp, "Settlement time not reached");
        
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        // 确保价格时间戳完全匹配结算时间
        if (priceData.publishTime == settlementTime && priceData.price > 0) {
            return (uint256(uint64(priceData.price)), true);
        }
        
        return (0, false);
    }
}
```

#### 1.3 时间窗口验证模式

```solidity
contract TimeWindowValidation {
    /// @notice 验证价格是否在指定时间窗口内
    function isPriceInTimeWindow(
        uint256 targetMinute,
        uint256 toleranceMinutes
    ) external view returns (bool inWindow, uint256 actualPrice) {
        require(targetMinute % 60 == 0, "Target must be minute-aligned");
        
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        
        // 检查价格是否在容忍时间窗口内
        uint256 timeDiff = priceData.publishTime > targetMinute ? 
            priceData.publishTime - targetMinute : 
            targetMinute - priceData.publishTime;
            
        if (timeDiff <= toleranceMinutes * 60 && priceData.publishTime % 60 == 0) {
            return (true, uint256(uint64(priceData.price)));
        }
        
        return (false, 0);
    }
}
```

### 2. 错误处理

```solidity
contract RobustPriceConsumer {
    IPyth public immutable pyth;
    
    enum PriceError {
        NONE,
        FEED_NOT_FOUND,
        PRICE_TOO_OLD,
        INVALID_PRICE,
        NOT_MINUTE_ALIGNED
    }
    
    function getSafeBTCPrice() external view returns (
        uint256 price,
        uint256 timestamp,
        PriceError error
    ) {
        try pyth.getPrice(BTC_FEED_ID) returns (IPyth.Price memory priceData) {
            if (priceData.price <= 0) {
                return (0, 0, PriceError.INVALID_PRICE);
            }
            
            if (priceData.publishTime % 60 != 0) {
                return (0, 0, PriceError.NOT_MINUTE_ALIGNED);
            }
            
            if (block.timestamp - priceData.publishTime > 300) {
                return (0, 0, PriceError.PRICE_TOO_OLD);
            }
            
            return (
                uint256(uint64(priceData.price)),
                priceData.publishTime,
                PriceError.NONE
            );
        } catch {
            return (0, 0, PriceError.FEED_NOT_FOUND);
        }
    }
}
```

### 2. 升级兼容性

```solidity
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

contract UpgradeablePriceConsumer is Initializable, OwnableUpgradeable {
    IPyth public pyth;
    
    function initialize(address _pyth) public initializer {
        __Ownable_init();
        pyth = IPyth(_pyth);
    }
    
    function updatePythOracle(address _newPyth) external onlyOwner {
        pyth = IPyth(_newPyth);
    }
}
```

## 常见问题解答

### Q1: getPriceAtZeroTimestamp 与 getPrice 有什么区别？

A: 两者的核心区别在于数据来源和用途：

```solidity
contract PriceFunctionComparison {
    IPyth public immutable pyth;
    bytes32 public constant BTC_FEED_ID = 0x7404e3d104ea7841c3d9e6fd20adfe99b4ad586bc08d8f3bd3afef894cf184de;
    
    /// @notice getPrice: 获取最新价格（实时数据）
    function getLatestPrice() external view returns (uint256 price, uint256 timestamp) {
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        return (uint256(uint64(priceData.price)), priceData.publishTime);
    }
    
    /// @notice getPriceAtZeroTimestamp: 获取指定时间的历史价格
    function getHistoricalPrice(uint256 timestamp) external view returns (uint256 price, bool exists) {
        require(timestamp % 60 == 0, "Must be minute-aligned");
        
        try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, timestamp) returns (IPyth.Price memory priceData) {
            if (priceData.publishTime == timestamp && priceData.price > 0) {
                return (uint256(uint64(priceData.price)), true);
            }
        } catch {
            return (0, false);
        }
        
        return (0, false);
    }
}
```

**关键区别：**
- `getPrice()`: 返回最新可用价格，时间戳可能不是整分钟
- `getPriceAtZeroTimestamp()`: 返回指定整分钟时间戳的精确历史价格

### Q2: 为什么 getPriceAtZeroTimestamp 有时会失败？

A: 常见失败原因及解决方案：

```solidity
contract HistoricalPriceErrorHandling {
    enum HistoricalPriceError {
        SUCCESS,
        INVALID_TIMESTAMP,    // 时间戳不是整分钟
        FUTURE_TIMESTAMP,     // 未来时间
        PRICE_NOT_AVAILABLE,  // 价格数据不存在
        PRICE_NOT_UPLOADED    // 价格尚未上传
    }
    
    /// @notice 带错误处理的历史价格查询
    function getHistoricalPriceWithError(uint256 timestamp) external view returns (
        uint256 price,
        HistoricalPriceError error
    ) {
        // 1. 验证时间戳格式
        if (timestamp % 60 != 0) {
            return (0, HistoricalPriceError.INVALID_TIMESTAMP);
        }
        
        // 2. 验证不是未来时间
        if (timestamp > block.timestamp) {
            return (0, HistoricalPriceError.FUTURE_TIMESTAMP);
        }
        
        // 3. 查询历史价格
        try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, timestamp) returns (IPyth.Price memory priceData) {
            if (priceData.publishTime == timestamp && priceData.price > 0) {
                return (uint256(uint64(priceData.price)), HistoricalPriceError.SUCCESS);
            } else {
                return (0, HistoricalPriceError.PRICE_NOT_AVAILABLE);
            }
        } catch {
            // 可能是价格尚未上传或永久不存在
            if (block.timestamp < timestamp + 300) { // 5分钟内
                return (0, HistoricalPriceError.PRICE_NOT_UPLOADED);
            } else {
                return (0, HistoricalPriceError.PRICE_NOT_AVAILABLE);
            }
        }
    }
}
```

### Q3: 如何在预测市场中正确使用 getPriceAtZeroTimestamp？

A: 预测市场的最佳实践模式：

```solidity
contract PredictionMarketBestPractice {
    struct Market {
        uint256 settlementTime;  // 必须是整分钟
        bool settled;
        uint256 settlementPrice;
    }
    
    /// @notice 创建预测市场
    function createMarket(uint256 _settlementTime) external {
        require(_settlementTime % 60 == 0, "Settlement time must be minute-aligned");
        require(_settlementTime > block.timestamp + 300, "Settlement time too soon");
        
        // 创建市场逻辑...
    }
    
    /// @notice 结算市场（推荐模式）
    function settleMarket(uint256 marketId) external {
        Market storage market = markets[marketId];
        require(!market.settled, "Already settled");
        
        // 等待宽限期，确保价格已上传
        require(block.timestamp >= market.settlementTime + 60, "Wait for price upload");
        
        // 获取精确的结算价格
        IPyth.Price memory settlementPrice = pyth.getPriceAtZeroTimestamp(
            BTC_FEED_ID, 
            market.settlementTime
        );
        
        require(settlementPrice.publishTime == market.settlementTime, "Price timestamp mismatch");
        require(settlementPrice.price > 0, "Invalid settlement price");
        
        market.settlementPrice = uint256(uint64(settlementPrice.price));
        market.settled = true;
        
        // 执行结算逻辑...
    }
    
    /// @notice 检查市场是否可以结算
    function canSettle(uint256 marketId) external view returns (bool ready, string memory reason) {
        Market storage market = markets[marketId];
        
        if (market.settled) {
            return (false, "Already settled");
        }
        
        if (block.timestamp < market.settlementTime) {
            return (false, "Settlement time not reached");
        }
        
        // 检查历史价格是否可用
        try pyth.getPriceAtZeroTimestamp(BTC_FEED_ID, market.settlementTime) returns (IPyth.Price memory priceData) {
            if (priceData.publishTime == market.settlementTime && priceData.price > 0) {
                return (true, "Ready to settle");
            } else {
                return (false, "Settlement price not valid");
            }
        } catch {
            if (block.timestamp < market.settlementTime + 300) {
                return (false, "Wait for price upload");
            } else {
                return (false, "Settlement price not available");
            }
        }
    }
}
```

### Q4: getPriceAtZeroTimestamp 的 Gas 消耗如何优化？

A: Gas 优化策略：

```solidity
contract GasOptimizedHistoricalPrice {
    // 1. 缓存策略
    mapping(bytes32 => mapping(uint256 => uint256)) private priceCache;
    mapping(bytes32 => mapping(uint256 => bool)) private priceExists;
    
    /// @notice Gas优化的历史价格查询
    function getOptimizedHistoricalPrice(bytes32 feedId, uint256 timestamp) external returns (uint256 price) {
        // 检查缓存
        if (priceExists[feedId][timestamp]) {
            return priceCache[feedId][timestamp];
        }
        
        // 查询并缓存
        try pyth.getPriceAtZeroTimestamp(feedId, timestamp) returns (IPyth.Price memory priceData) {
            if (priceData.publishTime == timestamp && priceData.price > 0) {
                price = uint256(uint64(priceData.price));
                priceCache[feedId][timestamp] = price;
                priceExists[feedId][timestamp] = true;
                return price;
            }
        } catch {
            // 缓存失败结果，避免重复查询
            priceExists[feedId][timestamp] = true;
            priceCache[feedId][timestamp] = 0;
        }
        
        return 0;
    }
    
    // 2. 批量查询
    function batchGetHistoricalPrices(
        bytes32 feedId,
        uint256[] calldata timestamps
    ) external view returns (uint256[] memory prices, bool[] memory successes) {
        prices = new uint256[](timestamps.length);
        successes = new bool[](timestamps.length);
        
        for (uint256 i = 0; i < timestamps.length; i++) {
            try pyth.getPriceAtZeroTimestamp(feedId, timestamps[i]) returns (IPyth.Price memory priceData) {
                if (priceData.publishTime == timestamps[i] && priceData.price > 0) {
                    prices[i] = uint256(uint64(priceData.price));
                    successes[i] = true;
                }
            } catch {
                // 保持默认值 (0, false)
            }
        }
    }
    
    // 3. 事件监听优化
    event HistoricalPriceRequested(bytes32 indexed feedId, uint256 indexed timestamp);
    
    function requestHistoricalPrice(bytes32 feedId, uint256 timestamp) external {
        emit HistoricalPriceRequested(feedId, timestamp);
        // 链下服务可以监听此事件，预先准备价格数据
    }
}
```

### Q5: 如何确保获取的是整分钟价格？

A: 在合约中验证 `publishTime % 60 == 0`：

```solidity
function ensureMinutePrice(bytes32 feedId) external view returns (uint256) {
    IPyth.Price memory priceData = pyth.getPrice(feedId);
    require(priceData.publishTime % 60 == 0, "Not a minute-aligned price");
    return uint256(uint64(priceData.price));
}
```

### Q2: 整分价格的更新频率是多少？

A: 整分价格每分钟更新一次，在每个整分钟时刻（如 07:10:00、07:11:00）推送新的价格数据。价格推送服务会在整分钟开始时立即获取最新价格并推送到链上。

### Q3: 如何在预测市场中使用整分价格？

A: 预测市场应该使用特定分钟的价格作为结算基准：

```solidity
function settlePrediction(uint256 predictionId) external {
    Prediction storage prediction = predictions[predictionId];
    IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
    
    // 确保价格时间戳完全匹配结算时间
    require(priceData.publishTime == prediction.settlementTime, "Price timestamp mismatch");
    require(priceData.publishTime % 60 == 0, "Not minute-aligned price");
    
    // 使用该价格进行结算
    uint256 settlementPrice = uint256(uint64(priceData.price));
    // ... 结算逻辑
}
```

### Q4: 如何处理价格延迟或缺失？

A: 实现容错机制和时间窗口验证：

```solidity
function getPriceWithFallback(uint256 targetMinute) external view returns (
    uint256 price, 
    bool found
) {
    IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
    
    // 首先检查精确匹配
    if (priceData.publishTime == targetMinute) {
        return (uint256(uint64(priceData.price)), true);
    }
    
    // 检查是否在合理的时间窗口内（例如1分钟容差）
    uint256 timeDiff = priceData.publishTime > targetMinute ? 
        priceData.publishTime - targetMinute : 
        targetMinute - priceData.publishTime;
        
    if (timeDiff <= 60 && priceData.publishTime % 60 == 0) {
        return (uint256(uint64(priceData.price)), true);
    }
    
    return (0, false);
}
```

### Q5: 整分价格机制对Gas消耗有什么影响？

A: 整分价格机制实际上有助于优化Gas消耗：
- **减少查询频率**: 应用只需在整分钟时刻查询价格
- **缓存友好**: 同一分钟内的多次查询可以复用结果
- **预测性**: 可以预先计算下次价格更新时间

```solidity
function ensureMinutePrice(bytes32 feedId) external view returns (uint256) {
    IPyth.Price memory priceData = pyth.getPrice(feedId);
    require(priceData.publishTime % 60 == 0, "Not a minute-aligned price");
    return uint256(uint64(priceData.price));
}
```

### Q6: 如何在合约中实现整分价格缓存？

A: 实现智能缓存机制以减少重复查询：

```solidity
contract PriceCache {
    struct CachedPrice {
        uint256 price;
        uint256 timestamp;
        bool valid;
    }
    
    mapping(bytes32 => mapping(uint256 => CachedPrice)) public priceCache;
    
    function getCachedMinutePrice(bytes32 feedId, uint256 minute) external returns (uint256) {
        require(minute % 60 == 0, "Not minute-aligned timestamp");
        
        CachedPrice storage cached = priceCache[feedId][minute];
        
        if (cached.valid) {
            return cached.price;
        }
        
        // 从Oracle获取价格
        IPyth.Price memory priceData = pyth.getPrice(feedId);
        require(priceData.publishTime == minute, "Price not available for this minute");
        
        // 缓存价格
        cached.price = uint256(uint64(priceData.price));
        cached.timestamp = priceData.publishTime;
        cached.valid = true;
        
        return cached.price;
    }
}
```

### Q7: 如何在DeFi协议中使用整分价格？

A: DeFi协议可以利用整分价格的一致性特点：

```solidity
contract LiquidationEngine {
    uint256 public constant LIQUIDATION_THRESHOLD = 150; // 150%
    
    function checkLiquidation(address user) external view returns (bool canLiquidate) {
        // 获取当前整分钟价格
        IPyth.Price memory priceData = pyth.getPrice(BTC_FEED_ID);
        require(priceData.publishTime % 60 == 0, "Waiting for minute-aligned price");
        
        uint256 collateralValue = getUserCollateral(user) * uint256(uint64(priceData.price));
        uint256 debtValue = getUserDebt(user) * 1e18;
        
        return (collateralValue * 100) < (debtValue * LIQUIDATION_THRESHOLD);
    }
}
```

### Q8: 如何处理价格延迟？

A: 使用 `getPriceNoOlderThan` 函数设置最大延迟时间，并结合整分价格验证：

```solidity
function getSafeMinutePrice(bytes32 feedId, uint256 maxAge) external view returns (
    uint256 price,
    uint256 timestamp
) {
    IPyth.Price memory priceData = pyth.getPriceNoOlderThan(feedId, maxAge);
    
    // 确保是整分价格
    require(priceData.publishTime % 60 == 0, "Not minute-aligned price");
    
    return (uint256(uint64(priceData.price)), priceData.publishTime);
}
```

### Q9: 如何优化Gas消耗？

A: 针对整分价格的Gas优化策略：

1. **批量查询多个整分价格**
```solidity
function getBatchMinutePrices(bytes32[] calldata feedIds) external view returns (
    uint256[] memory prices,
    uint256 timestamp
) {
    prices = new uint256[](feedIds.length);
    uint256 commonTimestamp;
    
    for (uint256 i = 0; i < feedIds.length; i++) {
        IPyth.Price memory priceData = pyth.getPrice(feedIds[i]);
        require(priceData.publishTime % 60 == 0, "Not minute-aligned");
        
        if (i == 0) {
            commonTimestamp = priceData.publishTime;
        } else {
            require(priceData.publishTime == commonTimestamp, "Timestamp mismatch");
        }
        
        prices[i] = uint256(uint64(priceData.price));
    }
    
    return (prices, commonTimestamp);
}
```

2. **使用事件监听整分价格更新**
3. **实现分钟级别的价格缓存**

## 整分价格获取 - 核心要点总结

### 🎯 整分价格机制的核心价值

1. **时间精确性**: 价格时间戳严格对齐到整分钟（`publishTime % 60 == 0`）
2. **一致性保证**: 同一分钟内所有查询返回相同的价格数据
3. **预测性**: 可预先计算下次价格更新时间，便于应用规划
4. **公平性**: 为预测市场、期权等应用提供公平的结算基准

### 🔧 关键实现模式

#### 基础验证模式
```solidity
modifier onlyMinutePrice(bytes32 feedId) {
    IPyth.Price memory price = pyth.getPrice(feedId);
    require(price.publishTime % 60 == 0, "Not minute-aligned price");
    _;
}
```

#### 安全获取模式
```solidity
function getSafeMinutePrice(bytes32 feedId) external view returns (uint256, uint256) {
    IPyth.Price memory price = pyth.getPrice(feedId);
    require(price.publishTime % 60 == 0, "Not minute-aligned");
    require(price.price > 0, "Invalid price");
    return (uint256(uint64(price.price)), price.publishTime);
}
```

#### 预测市场专用模式
```solidity
function getSettlementPrice(uint256 settlementTime) external view returns (uint256) {
    require(settlementTime % 60 == 0, "Settlement time must be minute-aligned");
    IPyth.Price memory price = pyth.getPrice(BTC_FEED_ID);
    require(price.publishTime == settlementTime, "Price timestamp mismatch");
    return uint256(uint64(price.price));
}
```

### 📊 性能优化建议

1. **缓存机制**: 同一分钟内复用价格数据
2. **批量查询**: 一次获取多个资产的整分价格
3. **事件监听**: 监听价格更新事件而非轮询
4. **时间窗口**: 合理设置价格有效期和容错范围

### ⚠️ 重要注意事项

- 始终验证 `publishTime % 60 == 0`
- 检查价格的有效性（非零、非负）
- 考虑网络延迟和价格推送时间
- 为关键应用实现降级和容错机制

## 总结

本文档详细介绍了如何在链上合约中调用 Oracle 价格数据，**特别专注于整分价格的获取和应用**。通过整分价格机制，开发者可以构建更加公平、一致和可预测的去中心化应用，特别适用于预测市场、期权交易、DeFi 协议等对价格时间精确性有严格要求的场景。

整分价格机制不仅提供了技术上的优势，更为区块链应用带来了业务层面的创新可能性，是构建下一代 DeFi 基础设施的重要工具。